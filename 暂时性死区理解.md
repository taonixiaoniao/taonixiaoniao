## let const var的区别

变量提升、暂时性死区、块级作用域、window、重名、const 实现、编译器

### 变量提升

```js
console.log(a)//undefined
var a = 1
console.log(a)//1
```

在上例中，var声明的变量能够提前使用，虽然只是undefined，但不会报错，这种提前使用称为变量提升。

```js
var a = 2
foo()
function  foo() {
    a = 3
    console.log(a); //3
    var a	
}
console.log(a);//2
```

在上例中，同样也发生了变量提升，foo函数在声明前就调用了、函数内a在打印后才定义，而且函数foo提升优先级高。

> 用var声明变量和不用var声明变量的区别之一：
>
> \- 在函数外，用var声明的变量为全局变量，不用var声明的变量为全局变量
>
> \- 在函数中，用var声明的变量为局部变量，不用var声明的变量为全局变量
>
> 
>
> 用var声明变量和不用var声明变量的区别之二：
>
> \- 同为全局变量，同为window对象的其中一个属性，用var声明的变量不可以删除，不用var声明的变量可以删除！
>
> \- 使用var 定义的变量为不可配置， 也可以使用Object.getOwnPropertyDescriptor()进行设置配置或Object.defineProperty()添加或修改变量

es5 的变量提升有特定，但不符合我们代码风格，代码的执行顺序和编写顺序最好一致，让代码可读性更高。

### 暂时性死区

```
console.log(alet);//ReferenceError: Cannot access 'alet' before initialization
let alet
console.log(alet);
alet = 10
console.log(alet);
```

let、const定义的变量不存在**"变量提升"**现象，即不能在定义变量前使用变量，提前使用保错现象称为暂时性死区。

为什么var能，而let、const不能呢？

实际上，Javascript对于变量，只有**两个限制**：

- 未初始化(`uninitialized`)的变量无法访问
- `let/const`这类声明的标识符不允许重复。

更多细节，就与**词法环境**中的**环境记录**有关了。

### 词法环境

[ES6 官方](https://link.juejin.cn?target=http%3A%2F%2Fecma-international.org%2Fecma-262%2F6.0%2F) 中的词法环境定义：

> **词法环境**是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义**标识符**和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用**外部词法环境**的空值组成。

简单来说 **词法环境** 是一种持有 **标识符—变量映射** 的结构。这里的 **标识符** 指的是变量/函数的名字，而 **变量** 是对实际对象（包含函数类型对象）或原始数据的引用。

> 这块看不懂没关系，你可以把它理解为 ES3 中的 变量对象，因为它们本质上做的是类似的事情，这里只是先把官方给出的定义放上来。这块概念比较烦：词法环境还分为两种，然后内部有个环境记录器还分两种，，这些概念在后面会用列表的形式归纳整理出来详细说明。

**词法环境**有两种类型

- 全局环境（在全局执行上下文中）是一个没有外部环境的词法环境。全局环境的外部环境引用为 null。它拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。
- 函数环境，用户在函数中定义的变量被存储在环境记录中。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。

**词法环境**有三个组成成分

- 环境记录
- 对外部环境的引用
- 绑定this

### 环境记录

**环境记录**是用于**记录词法环境中的标识符与变量的映射**，但是要注意，这里的环境记录可以抽象为一个**特殊的对象**（如果对ES3版本有所了解的，就是活动对象和变量对象啦），它与一般对象也没什么不同。

- 举个例子，一个变量a,将他绑定到**环境记录**中，此时我们就可以直接`a=3`等直接访问和使用。

**环境记录**有两种类型

- 声明性环境记录 ：存储变量、函数和参数。一个函数环境包含声明性环境记录。用于**记录标识符与变量的映射**，但是它**只记录非var声明的标识符** ； 没有一个**关联的绑定对象**(binding object)。

  将所有非var声明的标识符实例化，但不初始化，也就是变量`uninitialized`状态。也就是说内存中已经给变量预留了空间，但没有和对应的标识符绑定关系。

  在执行阶段，并执行到声明语句时才会初始化绑定和赋值为undefined。所以这也是暂时性死区的原因。

  在声明式环境记录中，不允许出现重复的标识符，所以它无法重复。甚至和`var`声明的标识符冲突。注意，它会在代码加载后的预编译阶段（只能说是运行前，因为JS没有真正的预编译啊……）就已经完成。

  

- 对象环境记录 ：用于定义在全局执行上下文中出现的变量和函数的关联。用于**记录标识符与变量的映射**，但是它**只记录var声明的标识符** ； 并且它有一个**关联的绑定对象**(binding object)。

  所有的标识符绑定到`绑定对象`的同名属性上，每个标识符在绑定后都会**直接实例化并初始化为undefined ，如果标识符已经绑定了绑定对象上的原有属性上，那么该变量就是对应属性值** 。这也是变量提升的原因。如果标识符已经存在，那么无视之，所以`var`可以重复声明。

  
