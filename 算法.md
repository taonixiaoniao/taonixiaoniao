# 算法笔记
一个好的算法必须要具备**准确性**和**健壮性**
- 准确性：必须能彻底解决对应的问题
- 健壮性：编写出的程序在任何情况下都不能崩溃
## 时间空间复杂度
### 时间复杂度
#### 频度
数据结构中，每条语句的执行次数，又被称为该语句的频度。整段代码的总执行次数，即整段代码的频度。
#### 最简频度
- 去掉频度表达式中，所有的加法常数式子。例如 2n^2+2n+1 简化为 2n^2+2n 
- 如果表达式有多项含有无限大变量的式子，只保留一个拥有指数最高的变量的式子。例如 2n^2+2n 简化为 2n^
- 如果最高项存在系数，且不为 1，直接去掉系数。例如 2n^ 系数为 2，直接简化为 n2 
#### 规范表达
在得到最简频度之后，用`O(最简频度)`来表示一个算法的时间复杂度
#### 常见时间复杂度
$$
O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)(立方阶) < O(2^n)(指数阶)
$$
### 空间复杂度
和时间复杂度类似，一个算法的空间复杂度，也常用大 O 记法表示。
如果程序所占用的存储空间和输入值无关，则该程序的空间复杂度就为 O(1)；反之，如果有关，则需要进一步判断它们之间的关系：

- 如果随着输入值 n 的增大，程序申请的临时空间成线性增长，则程序的空间复杂度用 O(n) 表示
- 如果随着输入值 n 的增大，程序申请的临时空间成 n2 关系增长，则程序的空间复杂度用 O(n2) 表示
- 如果随着输入值 n 的增大，程序申请的临时空间成 n3 关系增长，则程序的空间复杂度用 O(n3) 表示...
在多数场景中，一个好的算法往往更注重的是时间复杂度的比较，而空间复杂度只要在一个合理的范围内就可以。

## 排序
排序算法按照时间复杂度可以划分为三大类：O(n ^ 2)、O(nlogn)、O(n)

| 排序方法 | 平均时间复杂度 | 最好时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 |
| -------- | :------------: | :------------: | :------------: | :--------: | ------ |
| 冒泡排序 |     O(n^2)     |      O(n)      |     O(n^2)     |    O(1)    | 稳定   |
| 选择排序 |     O(n^2)     |     O(n^2)     |     O(n^2)     |    O(1)    | 不稳定 |
| 插入排序 |     O(n^2)     |      O(n)      |     O(n^2)     |    O(1)    | 稳定   |
| 希尔排序 |    O(n^1.3)    |      O(n)      |     O(n^2)     |    O(1)    | 不稳定 |
| 快速排序 |   O(n*log2n)   |   O(n*log2n)   |     O(n^2)     | O(n*log2n) | 不稳定 |
| 归并排序 |   O(n*log2n)   |   O(n*log2n)   |   O(n*log2n)   |    O(n)    | 稳定   |
| 堆排序   |   O(n*log2n)   |   O(n*log2n)   |   O(n*log2n)   |    O(1)    | 不稳定 |
| 基数排序 |   O(d(r+n))    |   O(d(n+rd))   |   O(d(r+n))    |  O(rd+n)   | 稳定   |



### O(n^2)排序算法

#### 冒泡排序
核心思路：双层循环，内循环中两两比较，将更大/更小的数往右移动，每次内循环完毕就有一个数移动到正确的位置。外层循环决定内循环的次数，数组中有多少个元素内循环就有几次。
- 后续可以经过一次优化减少外循环消耗，使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序，也就是终止外循环。
- 第二次优化可以减少内循环消耗，除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。
##### 初级冒泡排序
```js
// 封装一下交换元素的函数
const swap = (arr, i, j) => {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}

const bubbleSort = arr => {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
      }
    }
  }
  return arr
}
```
##### 一次优化冒泡排序
使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序，这样可以优化外循环，减少外循环次数。
```js
const swap = (arr, i, j) => {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}

const bubbleSort = arr => {
  let flag = true
  for (let i = 0; i < arr.length - 1; i++) {
    if (!flag) break
    flag = false
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
        flag = true
      }
    }
  }
  return arr
}
```
##### 二次优化冒泡排序
在一次优化的基础上，记录最后一个没有经过排序的元素下标和上次发生交换的位置，每次内循环从最后一个没有经过排序的元素位置开始，这样就减少了内循环的开销。
```js
const swap = (arr, i, j) => {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}

const bubbleSort = (arr) => {
  let swapped = true,
    // 最后一个没有经过排序的元素的下标
    indexOfLastUnsortedElement = arr.length - 1,
    // 上次发生交换的位置
    swappedIndex = -1
  while (swapped) {
    swapped = false
    for (let i = 0; i < indexOfLastUnsortedElement; i++) {
      if (arr[i] > arr[i + 1]) {
        // 如果左边的数大于右边的数，则交换，保证右边的数字最大
        swap(arr, i, i + 1)
        // 表示发生了交换
        swapped = true
        // 更新交换的位置
        swappedIndex = i
      }
    }
    // 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置
    indexOfLastUnsortedElement = swappedIndex
  }
  return arr
}
```
#### 插入排序
类似于打牌，每一个元素与前一位的元素作比较，如果小于前一位就往前挪，知道找到合适的位置。
- 外循环从1开始，直到最后一个元素，每次循环要用一个变量`target`保存该元素供内循环使用。
- 内循环从外循环的元素下标`i`开始，向左比较，如果`target < arr[j - 1]`，则`arr[j] = arr[j - 1]`，这里不要直接交换位置（浪费性能），最后内循环结束时再`arr[j] = target`，将最后需要交换的位置换过来。

上述操作等于是一直找左边大于`target`的元素，然后往右挪一位，直到找到合适的位置再将其赋值为`target`。

```js
function insertSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    const target = arr[i]
    let j = i
    while (j > 0 && arr[j - 1] > target) {
      arr[j] = arr[j - 1]
      j--
    }
    arr[j] = target
  }
  return arr
}
```
#### 选择排序
也是双循环，内循环找出最小的元素下标，每次内循环结束后交换头部元素与最小元素的位置。
- 外循环从`0 ~ (arr.length - 1)`，因为内循环时从`i + 1`开始的，这样可以节省一次循环的消耗。内循环开始前用`minIndex`保存下标`i`供内循环使用。
- 内循环从`i + 1`开始，直到最后一个元素。内循环每次判断`arr[j]`与`arr[minIndex]`的大小，将小的赋值给`minIndex`。
```js
const swap = (arr, i, j) => {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}

const selectionSort = arr => {
  for (let i = 0; i < arr.length - 1; i++) {
    let minIndex = i
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j
      }
    }
    swap(arr, i, minIndex)
  }
  return arr
}
```

选择排序可以优化，既然可以将最小的放到头端，于此同时也可以将最大的放到尾端。这样就能节省一半时间。
```js
const swap = (arr, i, j) => {
  const temp = arr[i]
  arr[i] = arr[j]
  arr[j] = temp
}

const selectionSort = arr => {
  for (let i = 0; i < arr.length / 2; i++) {
    let minIndex = i,
      maxIndex = i
    for (let j = i + 1; j < arr.length - i; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j
      }
        
      if (arr[j] > arr[maxIndex]) {
        maxIndex = j
      }
    }
    
    // 如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成
    if (minIndex === maxIndex) break
      
    swap(arr, minIndex, i)

    if (maxIndex === i) maxIndex = minIndex
    let lastIndex = arr.length - 1 - i
    swap(arr, lastIndex, maxIndex)
  }
    
  return arr
}

```

## 递归
### 递归三要素
- **确定递归函数的参数和返回值**： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
- **确定终止条件**： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
- **确定单层递归的逻辑**： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。
#### 二叉树前序遍历
- 确定递归函数的参数和返回值：因为要输出前序遍历节点的值，所以参数就传入节点
```js
const preorderTraversal = root => {}
```
- 确定终止条件：如果当前遍历的节点已经为 `null`，就说明本层递归结束了
```js
if (!root) return res
```
- 确定单层递归逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值
```js
 res.push(root.val)
preorder(root.left)
preorder(root.right)
```
- 完整代码如下：
```js
const preorderTraversal = (root) => {
  const res = []  // 用一个数组保存遍历的节点的值
  const preorder = root => {
    if (!root) return res // 该层遍历结束
    res.push(root.val) 
    preorder(root.left)
    preorder(root.right)
  }
  preorder(root)
  return res
}
```
## 二叉树
### 满二叉树
- 如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

<img src="C:\Users\21133\Pictures\js\manerchashu.png" alt="manerchashu" style="zoom:50%;" />

- 如图这棵二叉树为满二叉树，也可以说深度为 k，有 2^k-1 个节点的二叉树。

### 完全二叉树

- 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h -1  个节点。

<img src="C:\Users\21133\Pictures\js\wanquanerchashu.png" alt="wanquanerchashu" style="zoom:75%;" />

- 堆就是一棵完全二叉树，同时保证父子节点的顺序关系。
### 二叉搜索树
- 二叉搜索树又称为二叉排序树，它每个节点都是有数值的
- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
- 它的左、右子树也分别为二叉排序树，如下图就是两棵二叉搜索树

<img src="C:\Users\21133\Pictures\js\erchasousuoshu.png" alt="erchasousuoshu" style="zoom: 67%;" />

#### 平衡二叉搜索树
- 平衡二叉搜索树又被称为 `AVL（Adelson-Velsky and Landis）`树
- 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

<img src="C:\Users\21133\Pictures\js\pinghengerchasousuoshu.png" alt="pinghengerchasousuoshu" style="zoom:85%;" />

### 二叉树两种遍历
二叉树有两种遍历方式：
- 深度优先遍历：先往深走，遇到叶子节点再往回走。
- 广度优先遍历：一层一层的去遍历，遍历完一层再遍历下一层。
####  深度优先遍历
二叉树的优先遍历又分为三种，取决于遍历顺序里中间节点的位置：
- 前序遍历：中 -> 左 -> 右
- 中序遍历：左 -> 中 -> 右
- 后序遍历：左 -> 右 -> 中
##### 递归遍历
- 核心原理：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数
```js
// 前序遍历
const preorderTraversal = (root) => {
  const res = []
  const preorder = root => {
    if (!root) return res
    res.push(root.val)  // 中
    preorder(root.left)  // 左
    preorder(root.right)  // 右
  }
  preorder(root)
  return res
}

// 中序遍历
const inorderTraversal = (root) => {
  const res = [];
  const inorder = (root) => {
    if (!root) {
      return res
    }
    inorder(root.left)
    res.push(root.val)
    inorder(root.right)
  }
inorder(root)
return res
}

// 后序遍历
const postorderTraversal = (root) => {
  let res = []
  const postorder = root => {
    if (!root) return res
    postorder(root.left)
    postorder(root.right)
    res.push(root.val)
  }
  postorder(root)
  return res
}
```
##### 迭代遍历
- 递归遍历实际上自己维护了一个栈，而迭代就是要自己创建一个栈来存储遍历的节点
- 操作栈中节点时，出栈的顺序要与遍历顺序一致，因此入栈顺序是需要反过来的
```js
// 前序遍历
const preorderTraversal = (root) => {
  const res = [],
    stk = []
  if (root) stk.push(root)
  while (stk.length) {
    const node = stk.pop()
    console.log(stk, 'ssssssssss')
    console.log(node, 'nnnnnnnn')
    if (!node) {
      res.push(stk.pop().val) // stk出栈
      continue
    }
    if (node.right) stk.push(node.right) // 右节点入栈
    if (node.left) stk.push(node.left) // 左节点入栈
    stk.push(node) // 中间节点入栈
    stk.push(null)
  }
  return res
}

// 中序遍历
var inorderTraversal = function (root) {
  const res = [];
  const stk = [];
  while (root || stk.length) {
    while (root) {
      stk.push(root);
      root = root.left;
    }
    root = stk.pop();
    res.push(root.val)
    root = root.right;
  }
  return res
}

// 后序遍历
const postorderTraversal = (root) => {
  let res = [],
    stk = []
  if (root) stk.push(root)
  while (stk.length) {
    const node = stk.pop()
    if (!node) {
      res.push(stk.pop().val)
      continue
    }
    stk.push(node)
    stk.push(null)
    if (node.right) stk.push(node.right)
    if (node.left) stk.push(node.left)
  }
  return res
}
```
## KMP

全称 `Knuth-Morris-Pratt` 字符串查找方法，可以在一个字符串内查找一个子串
### 前置概念
- 前缀：包含首字母不包含尾字母的所有子串，以`aabaaf`为例，前缀如下
	- `a`、`aa`、`aab`、`aaba`、`aabaa`
- 后缀：包含尾字母不包含首字母的所有子串，以`aabaaf`为例，后缀如下
	-  `f`、`af`、`aaf`、`baaf`、`abaaf`
- 最长相等前后缀：对于 `aabaaf` 而言，逐个分析其所有子串的最长相等前后缀
	- `a` ： 0，因为单个字符串没有前后缀
	- `aa` ：1，前缀`a`与后缀`a`相等，长度为1
	- `aab`：0，没有相等的前后缀
	- `aaba`：1， 前缀`a`与后缀`a`相等，长度为1
	- `aabaa`：2，前缀`aa`与后缀`aa`相等，长度为2
	- `aabaaf`：0，没有相等的前后缀
- 前缀表：分析 `aabaaf` 所有子串得到的每个最长相等前后缀组成一个数列，就是前缀表，本例的前缀表为 `0 1 0 1 2 0`，前缀表中的每个数都对应着一个 `aabaaf` 的一个子串
- 前缀表的作用：某个字符不匹配时，确定下一步匹配中模式串应该回退到哪个位置。
### 原理
```js
// 查找文本串中是否包含模式串
文本串			aabaabaaf
模式串 		aabaaf 
模式串前缀表	  010120
前缀表中最大值为2，对应的子串为 aabaa，该子串中有长度为2的后缀`aa`对应着相等的前缀`aa`，该后缀的后续子串不匹配了，找到与其相等的前缀，该前缀的后面再拿出来去重新匹配，这样就避免了将整个模式串拿去重新匹配。在前缀表中记录着最长相等前后缀的长度，所以只要找到匹配冲突位置的前一个位置在前缀表中的值，然后拿这个值下标后面的串继续匹配
```
### next数组
next数组有三种
- 将前缀表作为 `next` 数组
- 前缀表整体向右移动一位，首位为 -1
- 前缀表整体减一
#### 构造next数组
构造 `next` 数组其实就是计算模式串 `s` 前缀表的过程，主要有如下三部
- 初始化
- 处理前后缀不相同的情况
- 处理前后缀相同的情况
##### 初始化
定义两个指针`i` `j`，`i` 指向前缀起始位置，`j` 指向后缀起始位置，再对 `next` 数组初始化
```js
let j = 0
next[0] = j
// next[i] 表示i（包括i）之前的最长相等前后缀长度
```
###### 前后缀不相等时
- `i` 从1开始，进行 `s[i]` 与 `s[j]` 的比较，如果二者不相等，说明前后缀末尾不相等，要向前回退。注意最多回退到起点，所以还要满足 `j > 0`。
- `next[j]` 记录着 `j（包含j）`之前的子串相等前后缀的长度，`s[i]` 与  `s[j]` 不相等，就要找到	`j` 前一个元素在 `next` 数组中的值，也就是 `next[j - 1]`
```js
for (let i = 1; i < s.length; i++) {
	while (j > 0 && s[i] !== s[j]) {
		j = next[j - 1]
	}
}
```
- 如果前缀表整体右移，则 `s[i]` 与 `s[j + 1]` 比较
- 前缀表整体减一时比较情况不变
##### 前后缀相等时
如果 `s[i] === s[j]`，说明找到了相等前后缀，需要同时将 `i` 和 `j` 向后移，同时将 `j（前缀长度）`赋给 `next[i]`，更新 `next` 数组
```js
if (s[i] === s[j]) {
	j += 1
}
next[i] = j
```
整体代码如下：
```js
const getNext = (next, s) => {
	let j = 0
	next[0] = j
	for (let i = 1; i < s.length; i++) {
        while (j > 0 && s[i] !== s[j]) { // 前后缀不相等
            j = next[j - 1] // 向前回退
        }
        if (s[i] === s[j]) { // 前后缀相等
			j += 1
        }
        next[i] = j // 更新 next 数组
	}
}
```
### 利用next数组做匹配
在文本串 `s` 里 找是否出现过模式串 `t`
- 定义两个下标，`j`  指向模式串 `t` 起始位置，`i` 指向文本串 `s` 起始位置。
- `i` 从0开始遍历文本串
- `s[i]` 与 `t[j]` 作比较
	- `s[i] !== t[j]`，`j` 就需要根据 `next[j - 1]` 确定下次匹配的位置
	- `s[i] === t[j]`， `i` 和 `j` 同时向后移动
- 判断 `j` 是否指向模式串 `t` 的末尾，如果是则说明文本串中包含了模式串，否则未包含
完整代码如下
```js

```
## 动态规划
### 动态规划五步曲
- 确定状态转移数组 `dp[i]` 的含义
- 确定递推公式
- `dp[i]` 数组初始化
- 确定遍历顺序
- 打印 `dp[i]` 数组，调试 `bug`
### 例题分析
#### 斐波那契数
##### 题目描述
斐波那契数，通常用 `F(n)` 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
$$
F(0) = 0，F(1) = 1,
F(n) = F(n - 1) + F(n - 2)
$$
其中 `n > 1`
给你 `n`，请计算 `F(n)` 。

##### 题解
###### 五步曲分析
- 状态转移数组 `dp[i]` 是第 `i` 个斐波那契数的值
- 递推公式，题目已给出 `F(n) = F(n - 1) + F(n - 2)`
- `dp` 数组初始化，`dp[0] = 0`，`dp[1] = 1`
- 遍历顺序：因为 `F(n) = F(n - 1) + F(n - 2)`，所以遍历顺序从前往后
###### 代码实现
```js
const fib = n => {
  if (!n) return 0
  let dp = []
  dp[0] = 0
  dp[1] = 1
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
}
```

