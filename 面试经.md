# html

## html5表单验证系列

###### html5新增标签

`email、url、number、range、date(date, month, week, time, datetime, datetime-local)、search、color、tel` 等

###### autocomplete

功能：文本框中，输入一次，下次输入会自动提示

###### 提示选择

<img src="C:\Users\21133\Documents\A-八股文手册\image\ceshi.png" alt="ceshi" style="zoom:80%;" />

使用`list`和`datalist`实现

###### 自动获取焦点

使用`autofocus`属性

###### 表单元素必填

使用`require`属性

###### 使用正则

需要使用`pattern`属性给表单添加正则约束
## HTML标签属性
### href && src
#### href
- 全名 `Hypertext Reference`（超文本引用）
- `href` 本质上是建立了一个通道，连接着外部资源，当点击带有`href`属性的标签时就能访问到资源
- `html` 中使用 `href` 属性的元素有：`link`、`a`
#### src
- 全名 `Source`（资源）
- `src`属性会引用外部资源时会把外部资源下载过来，并成为`html`文档的一部分，浏览器遇到`src`时会暂停其他资源的下载和处理，直到该`src`指向的资源下载编译执行完了之后才会进行下一步操作
- `html` 中使用 `src` 属性的元素有：`img`、`style`、`script`、`input`、`iframe`
#### 总结
- `href`：超链接，会建立通道，让当前元素或者文档与引用资源产生联系，需要引用资源时就能通过通道引用
- `src`：会把资源下载下来，然后代替当前的元素嵌入到`html`文档当中

## 事件冒泡/捕获
### 事件流
事件冒泡由微软公司提出、事件捕获由网景公司提出，这两个概念都是为了解决页面中**事件流**（事件发生顺序）的问题。
- 事件冒泡是一种事件流，在事件冒泡中，事件从最内层的元素开始发生，一直向上传播，直到`document`对象。
- 事件捕获是另一种事件流，与事件冒泡相反，在事件捕获中，事件从最外层开始发生，直到最内层的元素。
- 在捕获和冒泡同时存在的事件流中，事件的发生顺序应该是：捕获阶段 -> 目标阶段 -> 冒泡阶段。

<img src="C:\Users\21133\Pictures\js\shijianmaopao.png" style="zoom:100%;" />

如图，其中1~5是捕获过程，5~6是目标阶段，6~10是冒泡阶段。

### addEventListener第三个参数
`DOM2`事件中规定的事件流同时支持事件捕获和事件冒泡，`addEventListener第三个参数`方法用于给某个元素绑定一个事件处理函数，是`js`中常用的方法。`addEventListener(event, function, useCaptrue)`有三个参数：
1. `event`：指定事件名，必须是字符串，例如`click`表示点击事件。
2. `function`：指定事件触发时执行的函数。
3. `useCaptrue`：可选，布尔值，指定是否在事件捕获阶段执行函数。默认值是`false`，事件在冒泡阶执行。

### 事件代理
> 在实际开发中，利用事件流的特性，我们可以使用一种叫事件代理的方法。

场景如下：一个`ul`标签中包含多个`li`标签，我们想在点击`li`标签时触发一个事件，打印`li`标签中的文本。常规的做法是遍历每个`li`上绑定一个点击事件
```js
let list = document.querySelector('ul')
let allLi = list.getElementByTagName('li')
for (let i = 0; i < allLi.length; i++) {
  allLi[i].addEventListener('click', function() {
    cnosole.log(this.innerHTML)
  })
}
```
这种做法在`li`比较少的时候可以使用，但如果有成百上千个`li`，那就回导致性能降低，这时就可以使用**事件代理**，利用事件流的特性，我们只绑定一个事件处理函数也可以完成。
```js
let list = document.querySelector('ul')
list.addEventListener('click', function(e) {
  if (e.target.nodeName === 'li') { // nodeName属性表示节点名称
    console.log(e.target.innerHTML)
  }
})
```
由于事件的冒泡机制，点击了`li`后会冒泡到`ul`，此时就会触发绑定在`ul`上的点击事件，再利用`target`找到实际发生的元素，就可以达到效果。

*使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法。假如上述案例中还有别的`DOM`元素（`span`、`button`等），我们就不必多次循环给每种元素绑定事件，直接在事件代理中的函数新增判断条件即可。*

### 阻止事件冒泡
1. 给子元素添加`event.stopPropagation()`，该方法只阻止事件冒泡，不阻止事件本身。
2. 在事件处理函数中`return flase`，不仅阻止了事件冒泡，还阻止了事件本身。
3. `event.target === event.currentTarget`，让事件触发的元素等于事件绑定的元素，这样也可以阻止事件冒泡。

### 阻止默认事件
1. `event.preventDefault()`，可以阻止元素的默认事件，比如阻止`form`表单默认的提交行为。
2. `return false`。

## HTML标签总览
### 简单功能标签
- `b`：粗体文本
- `br`：换行符
- `hr`：水平分隔线（`horizontal rule`）
- `tr`：定义 `HTML` 表格中的行， tr 元素包含一个或多个 th 或 td 元素
- `th`： `HTML` 表头单元格（包含头部信息），包含两行两列
- `td`： `HTML` 标准单元格（包含数据），包含两行两列

### 文本相关
- `textarea`：定义多行的文本输入控件，文本区可以容纳无限数量的文本；在文本输入区内的文本行间，用  `%OD%OA`（回车/换行）进行分隔；可以通过 `cols` 和 `rows` 属性来规定 `textarea` 的尺寸，不过更好的办法是使用 `CSS` 的 `height` 和 `width` 属性
```html
<textarea rows="3" cols="20">
在w3school，你可以找到你所需要的所有的网站建设教程。
</textarea>
```

- `mark`：定义带有记号的文本，文本高亮显示（h5）。
```html
<p>Do not forget to buy <mark>突出显示部分文本</mark> today.</p>  
<!--突出显示部分文本-->
```

### 菜单及选项相关
- `select`：创建单选或多选菜单
- `option`：定义下拉列表中的一个选项（一个条目），必须作为 `select` 子元素使用。`option` 具有如下属性：
    1. `disabled`：首次加载时被禁用
    2. `lable`：定义当使用 `<optgroup>` 时所使用的标注
    3. `selected`：页面首次渲染时表现为被选中状态
    4. `value`：定义送往服务器的选项值
- `optgroup`：定义一个选项组，将相关选项组合到一起
```html
<select>
  <option value ="first">first</option>
  <option disabled value ="second">second</option>
  <optgroup label="nums">
      <option value="1">1</option>
      <option value="2">2</option>
  </optgroup>
</select>
```


### H5新增标签
- `meter`：显示已知范围内的标量测量值。例如磁盘用量、查询结果的相关性。注意`mater`标签不应该用于进度条，进度条使用 `progress`。
```html
<meter value="3" min="0" max="10">十分之三</meter>
<-- min和max决定了显示的区间，value表示测量值，如果min大于等于value，测量值将被排除在区间之外（不显示） -->
```
- `progress`：标示任务的进度（进程），可用于显示进度条。
```html
<progress value="22" max="100"></progress>  
<!-- value表示当前进度，max表示最大进度 -->
```
- `iframe`：创建包含另一个文档的内联框架，也就是行内框架。`iframe`通过`src`属性将另一个`html`文档引入当前文档。
```html
<iframe src="./iframe.html" frameborder="1"></iframe>
<-- frameborder决定是否显示边框 -->
```

## DOM事件总览

*`DOM`事件名称都作为`addEventListener(){}`的第一个参数用于事件类型。*

- `load`：当整个页面所有依赖资源，包括样式表、图片、子框架等依赖资源都完成加载时，将触发该事件。
- `DOMContentLoaded`：当初始的`html`文档被完全加载和解析完成之后该事件就会触发，相较于`load`事件，无需等待样式表、图像和子框架等依赖资源的加载。requestAnimationFrame()`：该函数接受一个回调函数，该回调函数会在浏览器下次重绘之前执行。当我们准备更新动画时应该调用此方法。回调函数执行频率通常是每秒60次（即浏览器帧率）。

# css

## css可继承属性
`css`可继承属性可以根据`html`标签的类型分类。

### 所有元素可继承
- `visibility`——控制元素是否可见，元素仍然占有位置。
- `cursor`——控制光标类型（形状）。

### 行内元素可继承
- `letter-spacing`——控制字符之间的间距。
- `word-spacing`——控制单词之间的间距。
- `line-height`——控制行高，也就是两行文本基线之间的距离。
- `color`——控制文本颜色。
- `font`——设置字体属性。
- `font-family`——设置字体属于哪个系列，微软系列、苹果系列等等。
- `font-size`——设置字体大小。
- `font-style`——定义字体的斜体、倾斜或者正常样式。
- `font-weight`——定义文本的粗细。
- `text-decoration`——给文本添加修饰，在文本的某一高度定义一条线或者定义闪烁的文本。
- `text-transform`——控制文本的大小写。
- `direction`——定义文本书写的方向，从左到右或者从右到左。

### 块级元素可继承
- `text-indent`——规定段落首行的缩进。
- `text-align`——定义文本水平对齐方式。

### 列表元素可继承
- `list-style`——设置列表所有的属性，是一个融合的简写属性。
- `list-style-type`——设置列表标记类型。
- `list-style-position`——设置列表标记的位置。
- `list-style-image`——用图像替换列表的标记。
## css选择器
> `CSS`选择器是`CSS`规则的第一部分。它是元素和其他部分组合起来告诉浏览器哪个`HTML`元素应当是被选为应用规则中的`CSS`属性值的方式。选择器所选择的元素，叫做“选择器的对象”。***选择器用来指定网页上我们想要样式化的`HTML`元素***

基础的`css`选择器分为以下几大类：
1. 通配符选择器：`*{}`
2. 标签选择器：`div{}`
3. 类选择器：`.box{}`
4. `id`选择器：`#box{}`

### 属性选择器
```css
/* 选择所有含name属性的元素 */
[name] {}
/* 选择name为test的元素 */
[name=test]{}
/* 选择name属性中包含单词test的所有元素 */
[name~=test]
/* 选择name属性以单词test开头的所有元素，类似正则的^ */
[name^=test]{}
/* 选择name属性以单词test结尾的所有元素，类似正则的$ */
[name$=test]{}
/* 选择name属性中包含test子串的每个元素 */
[name*=test]
```
### 文档结构选择器
1. 后代选择器
```css
ul li{}
```
2. 子选择器
```css
ul > li > p{}
```
3. 相邻兄弟选择器
```css
h2 + p{}
```
4. 一般兄弟选择器
```css
/* 选择前面有h2元素的每个p元素 */
h1~p{}
```

### 伪类选择器
1. 文档根元素伪类：`:root{}`
2. 第n个孩子选择器：`nth-child(n)`
3. 同类型的的第n个元素：`nth-of-type(n)`
4. 父元素`element`第一个子元素：`element:first-child`，相当于`nth-child(1)`
5. 父元素`element`最后一个子元素：`element:last-child`
6. `element`父元素同类型第一个子元素：`element:first-of-type`
7. `element`父元素同类型最后一个子元素：`element:last-of-type`
8. `element`父元素唯一的子元素：`element:only-child`
9. 倒数第n个子元素：`:nth-last-child(n)`
10. 同类型倒数第n个子元素：`:nth-last-of-type(n)`

### 伪元素选择器
1. `element::first-letter`
2. `element::before`：在每个`element`元素内容之前插入内容。经常当做`div`用
3. `element::after`：在每个`element`元素内容之后插入内容，经常用于清除浮动
4. `::selection`：选择被用户选取的元素部分

## css选择器权重
`!important > 行内样式 > id > class > 属性选择器|伪类选择器 > 元素选择器`
权重有五个等级：
- `!important`
- `行内样式`
- `id选择器，权重为100`
- `class选择器，权重为10`
- `标签和伪类选择器，权重为1`

## 文本的操作

### 超宽文本替换为省略号

- 设置宽度
- 强制文本在一行内显示
- 隐藏溢出内容
- 溢出进行省略
```css
div {
    white-space: nowrap; // 规定段落中的文本不进行换行
    overflow: hidden; //超出则隐藏
    text-overflow: ellipsis; //隐藏部分替换为省略号
}
```

### 超出文本内容自动换行

- 中文

```css
white-space: normal //超出边框则换行，这个属性是默认属性，可以设置
```

- 英文

```css
word-break: break-all //允许在长单词数字内部进行换行
```

## 重排（回流）&&重绘
### 浏览器渲染过程

![](C:\Users\21133\Pictures\js\liulanqixuanran.png)

根据上图可知浏览器渲染过程如下：
1. 解析`html`，生成`DOM`树；同时解析`css`生成`CSSOM`树；
2. 将`DOM`树和`CSSOM`树结合，生成渲染树（`render tree`）；
3. `layout（回流）`：根据生成的渲染树进行回流，得到节点的几何信息；
4. `painting（重绘）`：根据渲染树以及回流得到的几何信息，得到节点的绝对像素；
5. `display`：将像素发送给浏览器的`GPU`进程，`GPU`进程将其展示在页面上。`GPU`进程也有很多内容，例如将多个合成层合并为一个层，然后展示到页面中。

从这个过程可以看出，重排和重绘发生在浏览器渲染的不同阶段，***重排发生在根据`render tree`获取几何信息的阶段，而重绘发生在获取节点的绝对像素这一阶段***。

### 浏览器渲染各个阶段
#### 构建渲染树阶段
为了构建渲染树，浏览器主要做了以下工作：
1. 从`DOM`树的根节点中开始遍历每个可见节点。
2. 对于每个可见节点，找到`CSSOM`数中对应的规则，并应用它们。
3. 根据每个可见节点及其对应的样式，组合生成渲染树。

在第一步中浏览器需要判断什么节点可见，什么节点不可见。不可见的节点有如下情况：
1. 一些不会渲染输出的节点，比如`script`、`meta`、`link`等。
2. 一些通过`css`进行隐藏的节点，比如`display: none`。注意，使用`visibility`和`opacity`隐藏的节点只是视觉上不可见，还是会显示在渲染树上。

#### 回流阶段
浏览器在**构造渲染树**阶段将`DOM`节点以及它对应的样式结合起来，但我们还需要计算`DOM`节点在设备窗口（`viewport`）内的确切位置和大小，这个计算的过程就是回流。

为了弄清楚每个`DOM`对象在页面上的确切大小和位置，浏览器从渲染树的根节点开始遍历，直到最后一个子节点。这个过程中浏览器会根据窗口的具体大小，将元素的宽高转化为实际的像素值。

#### 重绘阶段
浏览器在构造渲染树和回流阶段确定了每个节点的样式以及几何信息，重绘阶段就是***将渲染树的每个节点转化为屏幕上的实际像素***。


### 重排重绘发生时机
#### 重排情况
> 当 `render` 树中的一部分或者全部因为大小边距等问题发生改变而需要 `DOM` 树重新计算的过程。

- 添加、删除可见的 `DOM`
- 元素位置改变
- 元素尺寸改变
- 页面渲染初始化
- 浏览器窗口大小改变
- 设置 `style` 属性
- 改变文字大小
- 添加/删除样式表
- 激活伪类
- 操作 `class` 属性
- 内容改变，用户在输入框输入内容也会

常见引起重排的属性如下表：

|       `width`       |       `height`       |    `padding`     |    `margin`    |
| :-----------------: | :------------------: | :--------------: | :------------: |
|      `display`      |    `border-width`    |     `border`     |     `top`      |
|     `position`      |     `font-size`      |     `float`      |  `text-align`  |
|     `overflow`      |    `font-weight`     |    `overflow`    |     `left`     |
|    `font-family`    |    `line-height`     | `vertical-align` |    `right`     |
|       `clear`       |    `white-space`     |     `bottom`     |  `min-height`  |
|     `offsetTop`     |     `offsetLeft`     |  `offsetWidth`   | `offsetHeight` |
|     `scrollTop`     |     `scrollLeft`     |  `scrollWidth`   | `scrollHeight` |
|     `clientTop`     |     `clientLeft`     |  `clientWidth`   | `clientHeight` |
| `getComputedStyled` | `currentStyle in IE` |                  |                |

#### 重绘情况：
> 当元素的一部分属性发生改变，如外观、背景、颜色等不会引起布局变化，只需要浏览器根据元素的新属性重新绘制 ，使元素呈现新的外观叫做重绘。 

*重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）*。

常见引起重绘的属性如下表：

|      `color`      |   `border-style`   |     `visibility`      |    `background`     |
| :---------------: | :----------------: | :-------------------: | :-----------------: |
| `text-decoration` | `background-image` | `background-position` | `background-repeat` |
|  `outline-color`  |     `outline`      |    `outline-style`    |   `border-radius`   |
|  `outline-width`  |    `box-shadow`    |   `background-size`   |                     |

### 浏览器优化机制
每次重排都会早造成额外的计算消耗，现代大多数浏览器都会通过***队列化修改并批量执行***来优化重排过程。浏览器会将修改操作放入队列中，直到过了一段时间或者操作达到了一个阈值才会清空队列。注意，***执行获取布局信息的操作时会强制刷新队列***。以下属性或者方法的访问会强制刷新：

- `offsetTop`、`ofsetLeft`、`offsetWidth`、`offsetHeight`
- `scrollTop`、`scrollLeft`、`scrollWidth`、`scrollHeight`
- `clientTop`、`clientLeft`、`clinetWidth`、`clinetHeight`
- `getComputedStyle()`
- `getBoundingClientRect()`

以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。

### 减少重绘和重排
重绘和重排是不可避免的，页面在首次渲染时就必有重绘和重排，但在后续更新的过程中我们应该尽可能减少重排和重绘发生的次数。

#### 最小化重绘重排（修改class）
不要一条一条地修改 `DOM` 的样式。可以先定义好 `css` 的 `class`，然后修改 `DOM` 的 `className`，这样可以将样式或布局的改变合并，集中到一次处理中。
```js
const box = document.getElementById('box')
box.style.padding = '5px'
box.style.borderLeft = '1px';
box.style.borderRight = '2px';
```
上述案例中，`box`有三个会影响几何结构的属性被修改了，会引起三次回流。现代大部分浏览器都做了优化，只会触发一次重排，但如果是在旧版的浏览器执行上述代码时，会导致三次重排。因此我们可以定义一个`box2`的样式，然后将`box`的`id`更改为`box2`。

#### 批量修改DOM（独立文档流）
当我们需要对`DOM`进行大量修改的时候，可以通过以下步骤减少重排重绘次数：
1. 使元素称为独立的文档流
2. 对其进行一系列修改
3. 让元素回到原来的文档流冲

该过程的第一步第三步都可能会引起周围元素的回流，但对`DOM`的修改不会再引起回流重绘，因为它已经不在渲染树中了。

以下方法可以让`DOM`称为独立文档流：
-  `display: none`；
-  使用文档片段`document fragment`在当前`DOM`之外构建一个子树，再把它拷贝回文档。创建`fragment`的方法是`document.createFragment()`，拷贝回文档的方法是`element.appendChild(fragment)`。

上述两种方法的性能并不理想，因为现代浏览器会用队列来存储多次修改进行优化。

#### 避免触发同步布局事件
上面说过，在访问元素的一些属性时，浏览器会强制清空队列，进行强制同步布局。例如，我们将一个`p`标签的宽度赋值为一个元素的宽度，我们可能写出这样的代码：
```js
function fn() {
  for (let i = 0; i < paragraphs.length; i++ ) {
    paragraphs[i].style.width = box.offsetWidth + 'px';
  }
}
```

上述代码在每次循环时都读取了`box`的`offsetWidth`属性的值，然后利用这个值更新`p`标签的`width`属性。浏览器为了保证上一次循环中的样式更新生效，***每次循环都会强制刷新队列***。对此我们可以做如下优化：

```js
const width = box.offsetWidth;
function fn() {
  for (let i = 0; i < paragraphs.length; i++) {
    paragraphs[i].style.width = width + 'px'
  }
}
```

优化后我们将`box.offsetWidth`用一个变量保存了起来，这样就避免了在每次循环中读取这个属性，从而减少了重排重绘。

#### 复杂动画优化
复杂动画经常会引起重排重绘，因此可以使用绝对定位，让它脱离文档流，否则会引起父元素以及后续元素频繁的重排。

## flex布局
- `flex` 是一种一维的布局模型，一个`flexbox`一次只能处理一个维度上的元素布局，一行或者一列
- `flex` 布局又称为弹性布局
### 两根轴线
使用 `flex` 布局可以抽象为两根轴线（主轴和交叉轴），主轴由 `flex-direction` 定义，另一根轴垂直于它，`flex` 所有属性都跟着两个根轴线有关。
#### 主轴（ `flex-direction`）
`flex-direction` 可以取四个值：
1. `row` ：水平方向从左向右延伸，左边为起始线，右边为终止线
2. `row-reverse`：水平方向从右向左延伸，右边为起始线，左边为终止线
3. `column`：主轴和交叉轴交换，沿垂直方向从上往下延伸，上边为起始线，下边边为终止线
4. `column-reverse`：主轴和交叉轴交换，沿垂直方向从下往上延伸，下边为起始线，上边为终止线
#### 交叉轴
交叉轴垂直于主轴
### flex容器
- 文档中采用了 `flexbox` 的区域就叫做 `flex` 容器。
将容器设为 `display: flex`或 `display: inline-flex`就创建了一个 `flex` 容器，容器中的直系子元素会变成 `flex` 元素。
### flex元素初始特性
- 元素排列为一行 (`flex-direction` 属性的初始值是 `row`)。
- 元素从主轴的起始线开始。
- 元素不会在主维度方向拉伸，但是可以缩小。
- 元素被拉伸来填充交叉轴大小。
- `flex-basis` 属性为 `auto`。规定了 `flex` 元素在主轴方向上的初始大小自适应。
- `flex-wrap` 属性为 `nowrap`。规定了 `flex` 元素是否应换行，这里为不换行。

**效果**：`flex` 元素线性排列，并且把自己的大小作为主轴上的大小。如果有元素过多超出容器，它们不会换行，而是会缩小以适应容器，如果无法缩小就会溢出容器。如果一些元素比其他元素高，那么元素会沿交叉轴被拉伸来填满它的大小。

### flex容器的属性
1. `flex-direction`：设置主轴的起始点、终止点和排列方向
- `row` ：水平方向从左向右延伸，左边为起始线，右边为终止线
- `row-reverse`：水平方向从右向左延伸，右边为起始线，左边为终止线
- `column`：主轴和交叉轴交换，沿垂直方向从上往下延伸，上边为起始线，下边为终止线
- `column-reverse`：主轴和交叉轴交换，沿垂直方向从下往上延伸，下边为起始线，上边为终止线

2. `flex-warp：`：规定 `flex` 元素是否换行
- `nowrap`：不换行
- `wrap`：自动换行（超出则换行）
- `wrap-reverse`：自动换行，但是是反方向
- `inherit`：继承父元素的 `flex-wrap` 属性

3. `flex-flow`：`flex-direction` 和 `flex-wrap` 的组合简写，第一个值规定 `direction` ，第二个值规定 `wrap`

`flex`布局中`flex-basis`与`width`的区别：`flex-basis`不一定是水平方向上的宽度，如果父元素是`flex-cloumn`，那么`basis`就是垂直方向的高度了。
### flex元素的属性
1. `flex-grow` ：规定容器中的 `flex` 元素的增长系数（该系数是数值），也就是相对其余 `flex` 元素的增长量 。默认值为0，不能为负。
2. `flex-shrink`：指定了`flex`元素的收缩规则。`flex`元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据`flex-shrink`的值（0 ~ 1），0 表示不收缩，1 是初始值。
3. `flex-basis`：指定了`flex`元素在主轴方向上的初始大小。
- 如果不使用`box-sizing`改变盒模型，这个属性就决定了`flex`元素的内容盒（`content-box`）的尺寸。
- 如果 `flex` 元素还设定了 `width` 或者 `height`，`flex-basis` 具有优先级更高


## position
`positioin`属性用于指定一个元素在文档中的定位方式，元素使用`position`之后，`top、right、bottom、left`属性就决定了该元素的最终位置。
### 元素定位类型
`html`文档中元素的定位有以下几种类型：
1. **定位元素**：`position`属性不为`static`以外的元素。
2. **相对定位元素**：`position`属性为`relative`的元素。
3. **绝对定位元素**：`position`属性为`absolute`或者`fixed`的元素。
4. **粘性定位元素**：`position`属性为`sticky`的元素。
### position属性详情
1. `position: static`：默认值，元素使用正常的布局行为，出现在正常的文档流中，也就是跟没用一样。
2. `position: relative`：生成相对定位的元素，相对于其正常位置进行定位。
3. `position: absolute`：生成绝对定位的元素，相对于除`static`定位以外的第一个使用`position`的祖先元素进行定位。
4. `position: fixed`：生成绝对定位元素，相对于浏览器窗口进行定位。
5. `position: sticky`：生成粘性定位元素，性对其正常位置进行定位，然后相对它最近的滚动祖先进行偏移（`left、right、bottom、top`）。

## css绘制图形

- `css` 绘制图形的核心是`css`盒模型的 `border`机制。
### 绘制三角形
- 将 `div` 宽高设为0
- 四边设置一定厚度的 `border`
- 将其中三边的 `border` 设置为 `transparent`
```css
width: 0px;
height: 0;
border: 50px solid transparent;
border-bottom-color: red;
```
### 绘制扇形
- 在绘制三角形的基础上加上 `border-radius: 50%`
```css
width: 0px;
height: 0;
border: 50px solid transparent;
border-radius: 50%;
border-bottom-color: red;
```
### 绘制梯形
- 在绘制三角形的基础上设置一定的宽度或高度
```css
width: 10px;
height: 0;
border: 50px solid transparent;
border-bottom-color: red;
```
## css水平居中
### text-aline: center
- `text-aline` 定义行内内容（例如文字）如何相对它的块父元素对齐。`text-align` 并不控制块元素自己的对齐，只控制它的行内内容的对齐。
- 因此 `text-aline` 能直接作用于 `p、h1~h5`，不能直接作用于 `span` 这样的行内元素，如果想作用于行内级元素，就需要给它套上一个块级父元素，然后给父元素设置 `text-aline`
### margin: 0 auto
- 上下外边距为0，左右自适应，只能作用于块级元素
- 使用 `margin: 0 auto` 水平居中，元素还必须有宽度，否则块级元素会横向占满窗口
### 脱离文档流 + transform
- 使用 `float + position:relative` 或者 `position` 的 `absolute` 或者 `fixed` 属性让元素脱离文档流
- `left:50%` 使元素左侧相对于窗口右移 `50%`
- `transform: translateX(-50%)` 让元素在水平方向反向平移自身宽度的 `50%`
```css
/* float + positon: relative */
float: left;
position:relative;
left:50%;
transform: translateX(-50%)

/* position: absolute */
position: absolute;
left:50%;
transform: translateX(-50%)
```
### flex + justify 
```html
<div class="box">
  <div class="son"></div>
</div>
```
```css
.box {
  display: flex;
  width: 100vw;
  height: 100vh;
  justify-content: center;
}

.son {
  width: 200px;
  height: 200px;
  background-color: red;
}
```
## css垂直居中
### 父元素padding
父元素上下设置相同的`padding`，其他部分全部由子元素撑开。

缺点：父元素不能设置固定高度

```html
  <div class="box">
    <span class="son">
      asdf
    </span>
  </div>
```
```css
.box {
  width: 200px;
  padding: 50px 0;
  background-color: pink;
}

.son {
  font-size: 20px;
  background-color: skyblue;
}
```
### line-hight
该元素定义了基线之间的距离，`line-height`与`font-size`计算值之差会分成两半加在元素的上面和下面，因此只要子元素的`line-height`的值与父元素高度相等，就可以使得子元素垂直居中

缺点：元素必须有高度；如果子元素不能有多行文字，只适用于单行文字或没有文字的情况。

```html
  <div class="box">
    <span class="son">
      asdf
    </span>
  </div>
```

```css
.box {
  width: 200px;
  height: 200px;
  background-color: pink;
}

.son {
  width: 20px;
  margin: 0 auto;
  font-size: 20px;
  background-color: skyblue;
  line-height: 200px;
}
```

### flex布局
父元素使用`flxe`布局，就可以使用`align-items`或者`justify-content`规定子元素在交叉轴和主轴的对齐方式。

缺点：兼容性稍差，`IE9`以上才能兼容
```html
  <div class="box">
    <span class="son">
      askjdhfksjad
    </span>
  </div>
```
```css
.box {
  width: 200px;
  height: 200px;
  background-color: pink;
  display: flex;
  align-items: center;
}

.son {
  font-size: 20px;
  background-color: skyblue;
}
```
`gird`布局适用于多行多列的布局，作为`gird`容器的父元素可以通过`grid-template-rows`和`grid-template-columns`来定义网格行和列的属性。

下面是一个单行三列的垂直居中：
### grid布局
```html
  <div class="box">
    <span class="son">
      a
    </span>
    <span class="son">
      b
    </span>
    <span class="son">
      c
    </span>
  </div>
```
```css
.box {
  width: 200px;
  height: 200px;
  background-color: pink;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  align-items: center;
}

.son {
  font-size: 20px;
  background-color: skyblue;
}
```

### 脱离文档流 + transform
子元素相对父元素脱离文档流，使用`top: 50%`相对父元素顶部向下偏移父元素高度的一般，然后子元素`transform: translateY(-50%)`向上偏移自身高度的一般即可垂直居中。

```html
  <div class="box">
    <span class="son">
      a
    </span>
    </span>
  </div>
```

```css
.box {
  width: 200px;
  height: 200px;
  background-color: pink;
  position: relative;
}

.son {
  position: absolute;
  font-size: 20px;
  background-color: skyblue;
  top: 50%;
  transform: translateY(-50%);
}
```
### inline-block + vertical-align
`vertical-align`规定了行内（`inline`）或者表格元素（`table-cell`）的垂直对齐方式。

给需要垂直居中元素设置`display: inline-block`，但是`vertical`需要另一个行内元素作为参照物，可以创建伪元素。

伪元素需要设置高度为`100%`，并且设置`vertical-align`为`middle`。因为`vertical-align`的对齐方式是基于基线的，哪个元素高度大就相对于哪个元素的基线，`100%`是为了确保伪元素高度高过需要垂直居中的元素，而伪元素的`vertical-align`是为了调整自身的基线。

```html
 <div class="box">
    <span class="son">
      a
    </span>
  </div>
```

```css
.box {
  width: 200px;
  height: 200px;
  background-color: pink;
}

.son {
  display: inline-block;
  font-size: 20px;
  background-color: skyblue;
  vertical-align: middle;
}

.box::after {
  content: "";
  display: inline-block;
  background-color: green;
  height: 50%;
  width: 0;
}
```

## line-hight
该属性是用来设置每行字体之间的行高的，行高指的是两行文字的基线之间的距离，基线是西方字母排列的基准线。

`line-height`与`font-size`的计算值之差分为两半，分别加到一个文本行内容的顶部和底部。可以包含这些内容的最小框就是行框。

`line-hright`可以设置四种值：
1. `normal`：默认值，浏览器会自动设置合理的值。
2. `px`：设置固定单位的行距。
3. `number`：设置数值，该数值乘以当前的`font-size`作为行间距。也就是多倍行距。
4. `%`：基于当前字体尺寸的百分比设置行距。
5. `inherit`：继承父元素的行距。

注意，设置固定行距或者百分比行距时，会先计算出父元素的行距再给子元素继承，如果子元素有很大字体，就有可能造成字体重叠。建议使用多倍行距，多倍行距是相对的，每个元素都会得到相对于自身字体大小的倍数的行距。

## calc()函数
`calc()`函数是`css3`新增的功能，它允许在设置一些`css`属性值时执行一些计算。

**注意**：`calc()`函数中使用`+` 、`-`计算符时左右两侧需要有一个空格。

`calc()`能帮助我们用相对简单地方式实现很多较复杂动态布局。例如：

1. 让元素水平居中并且指定左右离边界的距离，首先让元素脱离文档流，然后使用`left`指定左边界的距离（以`200`为例），元素的宽度设置为`calc(100% - 400)`，也就是父元素宽度减去两倍的左侧距离：
```html
 <div class="box"></div>
```

```css
.box{
  position: fixed;
  left: 200px;
  height: 200px;
  width: calc(100% - 400px);
  background-color: pink;
}
```

2. 实现上方固定下方自适应，上方元素指定高度（以`200`为例），下方元素高度设置为`calc(100% - 200px)`：
```html
  <div class="container">
    <div class="top"></div>
    <div class="buttom"></div>
  </div>
```

```css
    .container{
      margin: 0;
      padding: 0;
      width: 200px;
      height: 500px;
      border: 1px solid #000;
    }
    .left {
      width: 100%;
      height: 200px;
      background-color: red;
    }

    .right {
      width: 100%;
      height: calc(100% - 200px);
      background-color: blue;
    }
```

## 线性渐变函数
`css`可以给元素的背景设置渐变色，这个效果需要通过渐变函数`linear-gradient()`实现。
```css
background-image: line-gradient(to bottom, #fff, #fd0)
```
如上述代码所示，线性渐变函数有如下规则：
- 第一个参数表示颜色渐变的方向，默认从上往下，后续参数是参与渐变的颜色，颜色参数可以大于两个。
- 渐变方向用角度表示，单位为`deg`，有几个特殊的角度有对应的英文名称。

1. `0deg`可以写为`to top`，渐变方向为从下往上；
2. `90deg`可以写为`to right`，渐变方向为从左往右；
3. `180deg`可以写为`to bottom`，渐变方向为从上往下；
4. `270deg`可以写为`to left`，渐变方向为从右往左；

## css动画设置
`animation`关键字给`html`元素设置动画，可以设置六个动画属性：
1. `animation-name`：规定需要绑定到选择器的`keyframe`的名称；
2. `animation-duration`：规定完成动画需要花费的时间吗，单位为秒或者毫秒；
3. `animation-timing-funciton`：规定动画的速度曲线，是由快至慢或由慢至快或恒定速度；
4. `animation-delay`：规定动画开始前的延迟；
5. `animation-iteration-count`：规定动画播放的次数；
6. `animation-direction`：规定是否轮流反向播放动画。

上述六个动画属性可以单独设置，其他的属性会应用默认值。

动画的内容使用`@keyframe`定义，关键字后面写动画名称，名称后面是一个大括号，大括号中可以用百分比定义动画在关键帧的状态。

下面是一个`div`元素通过`css`动画变换自身颜色的案例：
```css
/* 动画代码 */
@keyframes example {
  0%   {background-color: red;}
  25%  {background-color: yellow;}
  50%  {background-color: blue;}
  100% {background-color: green;}
}

/* 应用动画的元素 */
div {
  width: 100px;
  height: 100px;
  background-color: red;
  animation-name: example;
  animation-duration: 4s;
}
```

## css动画对比js动画

### css动画
- `css3`动画又称为补间动画，只要添加关键帧的位置，其他未定义的帧会被自动生成
- 缺点：由于只设置了几个关键帧的位置，在动画进行的过程中想控制动画比较困难。想在中途暂停动画或者在动画过程中添加其他动作都会比较困难。
- 优点：
	1. 浏览器可以对动画进行优化
	2. 帧速不好的浏览器，`css3`可以自动降级兼容
	3. 代码简单，调试优化方向比较固定 
### js动画
- `js`动画是逐帧动画，在时间帧上绘制内容，
- 一帧一帧的，可塑性很高，几乎可以完成任何想要的动画形式。
- 缺点：由于逐帧动画的内容不一样，会增加制作的负担，占有较大的资源空间
- 优点：
	1. 动画是逐帧的，很细腻
	2. 可控性高
	3. 可塑性强，可以做出炫酷高级的动画
### 为什么css动画比js动画高效
1. 复杂性：`css`动画是补间动画，而`js`动画是逐帧动画，更复杂
2. 效率：使用`js`实现动画，无论多简单的动画都需要控制整个过程
3. 性能：
	- `js`动画很容易引起回流和重绘，动画的每一帧都导致整个`DOM`重新计算渲染，会造成浏览器内存堆积。同时由于`js`运行在浏览器的主线程中，主线程还有很多其他的任务在运行，很可能会因此受到干扰早上**线程阻塞**，从而**丢帧**
	- `css` 动画运行在合成线程中，不会阻塞主线程，合成线程中完成的动作不会引起回流和重绘。
	- `js`动画运行在`CPU`，而`css`动画运行在`CPU`。
4. 总的来说，`css`动画的渲染成本小，执行效率高于`js`动画。


# js

## 数据类型
### 基本数据类型（原始类型）
1. `String`：字符串，表示文本的序列。可以使用`new`运算符
2. `Number`：数字，64位双精度浮点型，有效精度为`[-2^53 + 1, 2^53 - 1]`，超出会失去精度。`js`中使用`Infinity`和`-Infinity`表示无穷大和无穷小。
3. `Boolean`：布尔值，`true || false`，表示真或假
4. `undefined`：表示声明未定义的变量的初始值，或没有实际参数的形式参数
5. `null`：表示一个不存在或者无效 `object` 或者地址引用
6. `bigint`：表示任意精度格式的**整数**，`number`精度范围有限制，`bigint`没有 
7. `symbol`：表示独一无二的值，一个具有数据类型 `symbol` 的值可以被称为 “符号类型值”，可以通过函数 `Symbol()` 创建，该函数可以传参

**注意**：所有基本类型的值都是不可改变的。但需要注意基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。

### number缺陷
1. `number`类型做数学运算的时候会先转化成二进制进行运算，然后再将结果转回十进制，这样就会有缺陷：
```js
console.log(0.1 + 0.2) // 0.30000000000000004
```
因为 0.1 和 0.2 转化为二进制都是无限循环的数，根据**`IEEE754`标准**，超出位数限制的多余的数会被截掉，此时就出现了精度的损失。

**解决方法**
`num.toFixed(digits)`：该方法使用定点表示法来格式化一个数值，返回用定点表示法表示给定数字的字符串。`digits`表示格式化后的数字保留几位小数，`digits`的取值范围是`0~20`，超出范围会报错。

```js
(0.1 + 0.2).toFixed(1)  // "0.3"
(0.111 + 0.222).toFixed(3) // 0.333
```

2. 超出`[-2^53 + 1, 2^53 - 1]`范围会失去精度。可以使用`bigInt`来做超出范围的整数计算。

### eval()运行字符串
`eval()`函数会将传入的字符串当做`js`代码运行。
```js
console.log(eval('2 + 2')) // 4

console.log(eval(new String('2 + 2'))) // '2 + 2'
```

## 检测数据类型
### typeof
- 作用：检测数据类型
- 返回值：小写字母字符串，也就是类型的名称
- 操作数：一个操作数，简单数据类型，函数，或者对象
- `typeof` 检测 `null` 也得出 `object` 结果，这是一个遗留已久的 `bug`，因为 `js` 最初是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 `null` 表示为全零，所以将它错误的判断为 `object` 。
- 缺点：`typeof` 检测除`Function`以外的引用数据类型时只能得出 `object` 的结果

```js
typeof 1 //number
typeof 'abc' //string
typeof true //boolean
typeof undefined // undefined
typeof [1, 2, 3] // object
typeof {a:1} // object
typeof null // object
typeof function(){} // function
typeof Symbol() //symbol
```
### instanceof
- 作用：检测一个对象是否是另一个对象的实例，判断一个构造函数的`prototype` 属性所指向的对象是否存在另外一个要检测对象的原型链上
- 返回值：返回的是布尔值
- 操作数：操作数有两个，分别参与 `instanceof` 左侧和右侧的运算
- 注意点：
1. `instanceof` 不能判断基本数据类型，运算符左侧的数据必须是引用数据类型，右侧必须是函数，否则得出的结果一定是 `false`
2. `null` 和 `undefined` 数据类型不能参与 `instanceof` 右侧的运算，会直接报错
3. `instanceof` 不能判断 `Symbol` 类型，因为 `Symbol` 不是构造函数，不能通过 `new` 运算符实例化
```js
// 判断实例是否属于它的父类
const Person = (name) {
	this.name = name
}
const yzx = new Person('yzx')
yzx instanceof Person // true

// 不使用 new 实例化的简单数据类型没有原型，结果为 false
let num1 = 1
num1 instanceof Number // false
let num2 = new Number(2)
nums2 instanceof Number // true

// 复杂数据类型不用 new 关键字也有原型
let fn = function(){}
fn instanceof Function // true

let obj = {a:1}
obj instanceof Object // true

// Symbol 不能实例化
let syb = symbal()
syb instanceof Symbol // false
```
### toString.call()
- ` Object.toString()` 能精准判断数据类型
- 缺点：语法稍显复杂，建议封装后使用
```js
// 封装
const determine = data => {
	return toString.call(data)
}

determine(()=>{})       // [object Function]
determine({})           // [object Object]
determine([])           // [object Array]
determine('')           // [object String]
determine(22)           // [object Number]
determine(undefined)    // [object undefined]
determine(null)         // [object null]
determine(new Date)     // [object Date]
determine(Math)         // [object Math]
determine(window)       // [object Window]
```

## 函数递归优化
### arguments.callee()
递归函数通常的形式是一个函数通过名称调用自己，下面是一个阶乘函数：
```js
function fn (num) {
  if (num <= 1) {
    return 1
  } 
  return num * fn(num - 1)
}
```
一般来说这样写没问题，但如果把函数赋值给另一个变量就会出问题，并且把原函数赋值为非函数的数据就会出问题：
```js
const fn1 = fn
fn = null
console.log(fn1(4)) // fn is not a function
```
这是因为`fn1`保留了一个对原始函数的引用，而在递归调用`fn1`时，其内部还是调用`fn`，然而此时`fn`已经不是函数了，所以报错。

`arguments.callee()`是一个指向正在执行的函数的指针，因此可以在函数内部递归调用：
```js
function fn(num) {
  if (num <= 1) return num
  return num * arguments.callee(num - 1)
}

const fn1 = fn
fn = null
console.log(fn1(4)) // 24
```

### 尾递归优化
`js`引擎对函数调用栈大小有限制，递归可能会出现调用栈溢出的问题。**尾递归**就是对递归的一种优化，能一定程度上减少递归调用栈使用的程度。

要弄清楚尾递归，先要搞清楚**尾调用**——当函数`a`的最后一个动作是调用函数`b`时（一般这个动作是`return`），那么对`b`函数调用的形式就是**尾调用**：
```js
function fn1(a) {
  const b = a + 1
  return b
}

function fn2(x) {
  const y = x + 1
  return fn1(y)
}

console.log(fn2(2)) // 4
```
在代码执行时，会产生一个调用栈，调用某个函数会将其压入栈，当它`return`后就会出栈，下图是上述代码调用栈的简易示例：

![](C:\Users\21133\Pictures\js\尾递归调用栈1.png)

1. `fn2`入栈，创建`x`、`y`并赋值，栈内记录相应信息，同时也记住被调用的地方，这样函数`return`后就知道结果应该返回到哪里；
2. `fn1`入栈，运行结束后出栈，`fn2`得到结果；
3. `fn2`返回结果并出栈，代码运行结束。

以上过程中，第二步和第三步的`fn2`一直存在于调用栈内，其实这是多余的，因此可以做如下优化：
*第二步调用`fn1`时先把`fn2`弹出调用栈，这样就减小了调用栈的使用大小*。这内部的实现是语言环境的事情，但我们要先把代码写成为调用的形式。

![](C:\Users\21133\Pictures\js\尾递归尾调用2.png)

 **尾递归**就是在递归中做**尾调用优化**，下面一段简单递归代码，用于计算1 ~ n的整数和：
```js
const sum = (n) => {
  if (n <= 1) return n;
  return n + sum(n - 1)
}
```
上述代码不是尾递归，因为`sum(n - 1)`调用后还需要进一步计算，当`n`较大时就会导致栈溢出，改成**尾递归**形式如下：
```js
const sum = (n, prevSum = 0) => {
  if (n <= 1) return n + prevSum;
  return sum(n-1, n + prevSum)
}
```

目前浏览器环境对尾递归优化支持情况并不好，只有`safari`（火狐）做了优化。这是因为*尾递归优化会破坏函数调用栈信息*，而且能做尾递归优化的函数是一定可以写成**迭代**形式的。

## 等号运算符

### == 与 === 的区别
`==` 运算符会进行类型的转换，转化规则如下：
1. 等号一侧为`string`，另一侧为`number`，则`string -> number`后再比较。
2. 等号任意一侧为`boolean`，则`boolean -> number`后再比较，其中`true -> 1`、`false -> 0`
3. 等号一侧为对象，另一侧不是，则调用对象的`valueOf()` 方法获取其原始值再比较。、
4. `null`和`undefined`不发生任何转化，但是`null == undefined`的返回结果为`true`。
5. 等号一侧为`NaN`，则任何情况下相等操作符返回`false`，不相等操作符返回`true`。即使是`NaN == NaN`返回的也是`false`。
6. 等号两侧都是对象，如果两个对象的引用地址相同则返回`true`，否则返回`fallse`


`===` 则不会进行类型转化，只有严格相等的两个操作数才会返回 `true`
#### 案例
```js
true == 1 // true
true === 1 //false
false == 0 // true
false === 0 //false
[] == 0 // true
[] === 0 // false
'123' == 123 //true
'123' === 123 //false
'' == 0 //true
'' === 0 //false
'' == false //true
'' === false //true
'   ' == false //true
'   ' === false //false 
'   ' == 0 //true
'   ' === 0 //false
null == undefined //true
null == 0 //false
'false' == false //false
NaN == NaN //false
NaN == false //false
NaN === false //false
```
- 两个引用类型计算的是引用地址，就算值一样也不相等。只有引用地址相同才相等。
```js
var a = {}
var b = {}
var c = a
a == b //false
a === b //false
a == c //true
a === c //false
```

易错案例

```js
"0" == false  // true
"" == []  // true
0 == []  // true
{} == 0 // false
```
#### 注意点

1. `'' 和 '  '`
字符串里如果没有值或者全部为空格，表示为假，在 `==` 运算符下与0、`false` 的返回值为 `true`
2. `null` 和 `undefined`
`null` 和 `undefined` 很特殊，它们都是假值，所以 `null == undefined` 返回为 `true`，因为是假值，它们不能转化为任何值，所以它们与任何其他的数据类型做 `==` 或 `===`运算返回值都是 `false`
3. `NaN`
`NaN` 表示非数字，是一个不确定的值，所以NaN与自身也是不相等的，与其他任何数据类型都不相等
4. 引用数据类型
对于引用数据类型来说，`==` 和`===`运算符计算的是它们的引用地址，如果引用地址相同则返回 `true`，否则返回`false`




## event_loop
事件循环，是指浏览器或`Node`中一种解决`javaScript`单线程运行时会阻塞的一种机制，也就是我们经常使用异步的原理。

### 进程与线程
- 进程是 `cpu` 资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- 线程是`cpu`调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
- 不同进程之间也可以通信，不过代价较大
- 单线程与多线程，都是指在一个进程内线程的的单和多

### 浏览器进程
浏览器是多进程的，其中包含了
1. ***主进程***
- 协调控制其他子进程（创建、销毁）
- 浏览器界面显示，用户交互，前进、后退、收藏
- 将渲染进程得到的内存中的`Bitmap`，绘制到用户界面上
- 处理不可见操作，网络请求，文件访问等

2. ***第三方插件进程***
- 每种类型的插件对应一个进程，仅当使用该插件时才创建

3. ***`GPU`进程***

- 用于3D绘制等	

4. ***渲染进程***，就是我们说的**浏览器内核**

- 负责页面渲染，脚本执行，事件处理等
- 每个`tab`页对应一个渲染进程

### 浏览器内容（渲染进程）
对于前端操作来说，最重要的是**渲染进程**，渲染进程是多线程的，分为如下几个线程
1. ***`GUI`渲染线程***
- 负责渲染页面，布局和绘制
- 页面需要重绘和回流时，该线程就会执行
- 与`js`引擎线程互斥，防止渲染结果不可预期

2. `JS`引擎线程
- 负责处理解析和执行`javascript`脚本程序
- 只有一个`JS`引擎线程（单线程）
- 与`GUI`渲染线程互斥，防止渲染结果不可预期

3. 事件触发线程
- 用来控制事件循环（鼠标点击、`setTimeout`、`ajax`等）
- 当事件满足触发条件时，将事件放入到`JS`引擎所在的执行队列中

4. 定时触发器线程
- `setInterval`与`setTimeout`所在的线程
- 定时任务并不是由JS引擎计时的，是由定时触发线程来计时的
- 计时完毕后，通知事件触发线程

5. 异步`http`请求线程
- 浏览器有一个单独的线程用于处理`AJAX`请求
- 当请求完成时，若有回调函数，通知事件触发线程
### event_loop机制
#### 重要概念
- `JS` 分为同步任务和异步任务。

- 同步任务都在`JS`引擎线程上执行，形成一个**执行栈**。

- 事件触发线程管理一个**任务队列**，异步任务触发条件达成，将回调事件放到**任务队列**中。

- 执行栈中所有同步任务执行完毕，此时`JS`引擎线程空闲，系统会读取任务队列，将可运行的异步任务回调事件添加到执行栈中，开始执行。

<img src="C:\Users\21133\Pictures\js\event_loop.png" alt="event_loop" style="zoom: 67%;" />

- `setTimeout/setInterval`和`XHR/fetch`代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。
- 异步任务发生时，回调事件会被放入由**事件触发线程**所管理的**事件队列**中。
- 同步任务执行完，`JS`引擎线程会询问事件触发线程，在事件队列中是否有待执行的回调函数，如果有就会压入到执行栈中交给`JS`引擎线程执行。

#### 核心机制
- `JS`引擎线程只执行执行栈中的事件
- 执行栈中的代码执行完毕，就会读取**任务队列**中的事件
- **任务队列中**的回调事件，是由各自线程插入到**任务队列**中的
- 如此循环就是 `event_loop` 机制
#### 宏任务微任务
在没有微任务的概念之前，上述  `event_loop` 就是完整的，后来**任务队列中**中的任务有一部分细分为微任务
##### 宏任务
- 可以将每次执行栈执行的代码当做是一个宏任务
- `JS` 引擎线程和 `GUI` 渲染线程是互斥的关系，浏览器为了能够使宏任务和` DOM` 任务有序的进行，在一个宏任务执行结果后，下一个宏任务执行前，`GUI` 渲染线程开始工作，对页面进行渲染。
- 主代码块（例如一整个 `script` 标签），`setTimeout`、`setInterval` 、事件触发等，都属于宏任务
##### 微任务
- 宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行产生的需要立即执行的任务。
- 当宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完，直到微任务队列为空。
- 微任务中可以排队新的微任务，这些微任务依然会在下一个宏任务开始之前执行完。
- 典型的微任务有 `promise.then()`、`peocess.nextTick`（node独有）。以 `Promise为例`，`new Promise()` 实例化以及 `resolve reject` 的过程是宏任务，而 `resolve` 之后的后 `promise.then()` 就是微任务。
- `js` 提供了 `queueMicrotask` 来创建微任务，`queueMicrotask(() =>{})`，微任务函数不传参也没有返回值。

#### 有宏任务微任务的event_loop
- 执行一个宏任务（执行栈中没有就把**任务队列**中的任务压入执行栈）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后`GUI`线程接管渲染
- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
如此循环往复就是 `event_loop`

## 原型链与继承
`javascript`高级程序设计对继承有这样一段描述：
> 继承是OO（面向对象）语言中一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：**接口继承**和**实现继承**。接口继承只继承方法签名，而实现继承则继承实际的方法。由于`js`中没有签名，在`ECMAScript`中无法实现接口继承，只支持实现继承。实现继承主要是依靠原型链来实现的。

### 构造函数、原型、实例关系
- *每个构造函数（`constructor`）都有一个原型对象（‘prototype’），原型对象都包含一个指向构造函数的指针，而实例（`instance`）都包含一个指向原型对象的内部指针。*
- *在`js`中引用对象（实例`instance`）的某个属性时，首先会在对象内部寻找这个属性，如果找不到就去该对象的原型（`instance.prototype`）里去找这个属性。*

如果让原型对象指向另一个类型的实例（`constructor1.prototype = instance2`），此时引用`instance1`（`constructor1`的实例）的某个属性`p1`，就会发生有趣的事情：
1. 在`instance1`内部找一遍。
2. 第一步如果没找到，接着在`instance.__proto__`中找一遍，而`instance1.__proto__ === constructor.prototype`，也就是`instance2`。也就是说在`instance2`中寻找`p1`。
3. 如果在`instance2`中还没找到，还会继续在`instance2.__proto__`中寻找，直到`Object`原型对象。

*搜索轨迹：`instance1 -> instance2 -> constructor2.prototype -> ... -> Object.prototype`*

这种搜索轨迹形似一条长链，其中`prototype`充当链接的作用，于是我们把这种实例与原型的链条称为**原型链**。

#### 确定原型和实例关系的方法
使用原型链后，我们有两种方法判断原型和实例之间的继承关系：
1. `instanceof`操作符，该操作符用来判断一个对象的`__proto__`是否与原型链上的某个构造函数的`prototype`相等，如果是就会返回`true`。
2. `isPrototypeOf()`，该方法用于判断一个对象是否存在于另一个对象的原型链上。

```js
function Father(name, age) {
  this.name = name
  this.age = age
}

Father.prototype = {
  color: 'red'
}

const son = new Father('yzx', 22)

console.log(Father.prototype.isPrototypeOf(son)) // true
console.log(son instanceof Father)  // true
```

### 原型链的问题
原型链有如下两个问题：
1. 当原型链中包含引用类型值的原型时，该引用类型会被所有实例共享。
2. 在创建子类型时，不能向超类型的构造函数中传递参数。
```js
function Father() {
  this.color = ['red']
}

function Son() {

}

Son.prototype = new Father() // 继承父类实例应有的属性和方法

const instance1 = new Son() 
console.log(instance1.color) // ['red']
instance1.color.push('blue') 
console.log(instance1.color) // ['red', 'blue']
const instance2 = new Son()
console.log(instance2.color) // ['red', 'blue'] instance2和instance1共享了color
```
为了解决这个问题，衍生出了几种方法来弥补原型链的不足。

### 继承方法

#### 借用构造函数
*借用构造函数就是在子类构造函数的内部调用父类构造函数，需要使用`call`。*

```js
function Father(name) {
  this.name = name
  this.color = ['red']
}

function Son(name) {
  Father.call(this, name)  //继承了Father,并向父类传参
}

const instance1 = new Son('yzx') 
console.log(instance1.color, instance1.name) // ['red']  yzx
instance1.color.push('blue') 
console.log(instance1.color, instance1.name) // ['red', 'blue']  hjy
const instance2 = new Son('hjy')
console.log(instance2.color) // ['red']

Father.prototype.getName = function() {
  return this.name
}

const fatherInstance = new Father('laowang')

console.log(fatherInstance.getName()) // laowang
console.log(instance1.getName()) // Uncaught TypeError: instance1.getName is not a function
console.log(instance2.getName()) // Uncaught TypeError: instance1.getName is not a function
```
构造函数解决了原型链的两个问题：
1. 保证了原型链中引用类型值的独立性，不再被所有实例共享。
2. 子类创建时也能给父类传递参数。

但这样又会出现新的问题：

- 借用构造函数，方法都在构造函数中定义，因此函数就不可复用了
- 父类原型中定义的属性和方法对子类而言不可见，也就是`Father.prototype`上的属性和方法`Son`无法继承。

因此，借用构造函数的技术也很少单独使用。

#### 组合继承
组合继承也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一起，发挥两者之长的一种继承模式。

*基本思路：使用原型链实现对原型属性方法的继承，通过借用构造函数来实现对实例属性的继承，即在原型上定义方法实现函数复用，又能保证每个实例有它自己的属性。*

```js
function Father(name) {
  this.name = name
  this.colors = ['red']
}

Father.prototype.getName = function () {
  return this.name
}

function Son(name, age) {
  Father.call(this, name) // 继承父类实例应有的属性，第一次调用Father
  this.age = age
}

Son.prototype = new Father() // 继承父类方法，第二次调用Father

Son.prototype.getAge = function () {
  return this.age
}

const instance1 = new Son('yzx', 22)
instance1.colors.push('blue')

const instance2 = new Son('hjy', 20)

console.log(instance1.colors) //  ['red', 'blue']
console.log(instance1.getName()) // yzx
console.log(instance1.getAge()) // 22
console.log(instance2.colors) // ['red']
console.log(instance2.getName()) // hjy
console.log(instance2.getAge()) // 20
```
组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为`javascript`中最常用的继承模式，而且 `instanceof`和`isPrototypeOf()`也能用于识别基于组合继承创建的对象。

*然而组合继承中调用了两次父类构造函数，造成了不必要的性能损耗，如何避免这种损耗？*

#### 原型继承
> 由道格拉斯.克罗克福德提出。借助原型可以基于已有的对象创建新对象，同时还不必因此自定义类型。

*在 object() 函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个实例。*

```js
function object(fn) {
  function F() { }
  F.prototype = fn
  return new F()
}

const obj = {
  name: 'yzx',
  colors: ['red', 'blue']
}

const person = object(obj)
person.colors.push('yellow') 
console.log(person.colors) // [ 'red', 'blue', 'yellow' ]

person.name = 'hjy'
console.log(person.name) // 'hjy'

const person2 = object(obj)
console.log(person2.colors) // [ 'red', 'blue', 'yellow' ]
console.log(person2.name) // 'yzx'
```
从本质上讲，`object()`对传入其中的对象做了一次浅拷贝。上述案例中，作为新对象基础的是`obj`对象，`object()`函数会返回一个新对象，这个新对象将`obj`作为原型，因此它的原型中就包含了引用类型值（`colors`），这意味着`obj.colors`不仅属于`obj`，还会被`person`、`person2`共享。

> 在`ECAMScript5`中，通过新增的`Object.create()`方法规范了上面的原型式继承

`Object.create()`接受两个参数：

1. 一个作为新对象原型的对象
2. 一个为新对象定义额外属性的对象

*`Object.create()`只有一个参数时与上面的`object()`方法功能相同，它的第二个参数与`Object.definedPrototies()`方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的，这种方法指定的任何属性都会覆盖原型对象上的同名属性。*

```js
const person = {
  name: 'laowang'
}

const person2 = Object.create(person, {
  name: { value: 'yzx' },
  age: { value: 18 }
})

console.log(person) // { name: 'laowang' }
console.log(person2.name, person2.age) // yzx 18
```
**注意**：原型式继承中，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。使用手写的`object()`方法无法传递参数，但如果使用`Object.create()`方法是可以传递参数的。

#### 寄生式继承
> 寄生式继承是与原型式继承紧密相关的一种思路，同样是克罗克福德推广的。

*寄生式继承的思路与构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的像是它做了所有工作一样返回对象。*

```js
function createAnther(original) {
  const clone = Object.create(original)
  clone.sayHi = function () {
    return 'hi'
  }
  return clone
}

const person = {
  name: 'yzx',
  age: 22,
  colors: ['red']
}

const person1 = createAnther(person)
person1.colors.push('blue')

console.log(person1.name) // yzx
console.log(person1.age) // 22
console.log(person1.colors) // ['red', 'blue']
console.log(person1.sayHi()) // hi
console.log(person.colors) // ['red', 'blue']
```
寄生式继承缺点：
1. 原型链中多个实例共享引用类型属性。
2. 无法传递参数
3. 函数不可复用

#### 寄生组合式继承
在组合式继承中，无论在哪种情况下都会调用两次构造函数，*一次是在创建子类原型的时候，另一次是在子类构造函数内部。*
***寄生组合式继承是为了降低调用父类构造函数的开销出现的，结合借用构造函数传递参数和寄生模式实现继承。***

```js
function extend(subClass, superClass) {
  // 复制一份父类的原型
  const prototype = Object.create(superClass.prototype) 
  // 将子类的prototype指向复制的父类原型
  subClass.prototype = prototype
  // 将复制的父类原型的constructor指向子类
  prototype.constructor = subClass
  
}

function Father(name) {
  this.name = name
  this.colors = ['red']
}

Father.prototype.getName = function () {
  return this.name
}
Father.prototype.getColors = function () {
  return this.colors
}

function Son(name, age) {
  // 调用构造函数继承父类实例应有的属性
  Father.call(this, name)
  this.age = age
}
extend(Son, Father) // 继承父类原型上的方法，这里不会调用Father()

const instance1 = new Son('yzx', 22)
instance1.colors.push('blue')

const instance2 = new Son('hjy', 19)

console.log(instance1.getName())
console.log(instance1.getColors())

console.log(instance2.getName())
console.log(instance2.getColors())
console.log(instance2.age)
```

# es6

## var_let_const
涉及知识点：变量提升、暂时性死区、块级作用域、`window`挂载
### var的缺点
- `var` 在全局作用域声明变量时，会将其挂载在 `window` 上
- 这样的变量对于全局来说就是一个污染
- 这个变量有可能会覆盖掉 `window` 上的属性
- `for`循环中定义`setTimeout`，`setTimeout`中打印`i`，会得到`n`次最后的`i`。
```js
for (var i = 0; i < 5; i++) {
  setTimeout(() => {
  	console.log(i)  // 1s后打印5个5
  }, 1000)
}
```
造成这种现象的原因主要有两个：
1. `var`存在变量提升，`for`循环条件里声明的`i`提升到了外部
2. `setTimeout`中的任务被放入了任务队列，等到里面的代理执行时，会通过词法作用域找到已经被提升的`i`，此时`i`已经变成了 5 

在`let`和`const`出现之前，可以用立即执行函数来解决这个问题。本质上就是立即执行函数会形成自己的词法作用域，等到任务队列中的`console.log(i)`执行时就会找到立即执行函数作用域中的`i`，而五个立即执行函数中的`i`就分别是`1, 2, 3, 4 ,5`了。
### 变量提升
提升是指 js 解析器将所有的变量声明和函数声明移动到当前作用域顶部的操作。提升可以分为两种：
- 变量提升
- 函数提升，函数提升优先级更高，`var`变量提升会初始化为 `undfined`，函数提升的同时函数的赋值操作也被提升了，能提前得到函数体
- 变量提升发生在代码的编译阶段，代码的执行发生在执行阶段
- `js` 编译解释过程如下：

<img src="C:\Users\21133\Documents\B-JS\js知识点\js知识点图解\jsbianyi.jpg" alt="jsbianyi" style="zoom: 80%;" />

### 暂时性死区

- `let`和`const`在全局声明时会先进入到一个作用域中，在函数声明前不可访问，声明后可以访问，就形成了暂时性死区，这个作用域独立在 `global` 全局作用域之外，并且与 `global` 一起被包裹在 `Scopes` 作用域中，这样 `let const` 声明的变量就不会污染全局。
-  广义上 `var let const` 都有变量提升，声明时会先形成作用域，从作用域角度理解它们都有变量提升。
```js
var a = 1
function fn() {
	console.log(a)
	let a = 2
}
fn() //Cannot access 'name' before initialization
```
分析以上代码，假如`let`没有变量提升，根据作用域的查找规则，函数 fn 应该会向上查找到全局作用域中的变量 a，这说明 let 有作用域的提升，但这个作用域中没有初始化变量，形成了暂时性死区，因此无法访问
- 狭义上`let const`没有变量提升，从代码运行角度上来讲，`var`的变量声明被提升到了代码的编译阶段，而`let`和`const`的声明在代码执行阶段，声明之前不可调用，因此`let const` 没有变量提升。

### 词法环境理解 var/let/const
实际上，`javascript`对变量只有两个限制：
1. 未初始化的变量无法访问。
2. `let/const`这类声明的标识符不允许重复。
更多细节就与**词法环境**中的**环境记录**相关

#### 词法环境
`ECMAScript`规范中对词法环境的定义如下：

> 词法环境是一种规范类型，基于`ECMAScript`代码的词法环境嵌套结构来定义**标识符**和具体变量和函数的关联。一个词法环境由环境记录器和一个可能引用的**外部词法环境**的空值组成。

简单来说**词法环境**是由一种持有**标识符——变量映射**的结构。这里的**标识符**指的是变量/函数的名字，而变量时是对实际对象或者原始数据的引用。

**词法环境**有两种类型：

1. 全局环境：存在于全局执行上下文中，是一个没有外部环境的词法环境。全局环境的外部环境引用为`null`，它拥有一个全局对象（`window`）及其关联的方法和属性以及任何用户自定义的全局变量，`this`的值指向这个全局对象。
2. 函数环境：用户在函数中定义的变量被存储在环境记录中。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。

**词法环境**三个组成部分：

1. 环境记录
2. 对外部环境的引用
3. 绑定`this`

#### 环境记录
**环境记录**是用于 ***记录词法环境中的标识符与变量的映射***，这里的**环境记录**可以抽象为一个**特殊的对象**，与一般的对象也没什么不同。

- 例如：将变量`a`绑定到环境记录中，直接`a = 3`就可以直接访问和使用。 

环境记录有两种类型：
1. 对象环境记录：
- 用于定义在全局执行上下文中出现的变量和函数的关联。用于***记录标识符与变量的映射***，但是它**只记录`var`声明的标识符**，并且它有一个***关联的绑定对象（`binding object`）***。
- 所有的标识符都绑定到**绑定对象**的同名属性上，每个标识符在绑定后都会直接***实例化并初始化`undefined`***，*如果标识符已经绑定了绑定对象上的原有属性，那么该变量就是对应的属性值*，这也是变量提升的原因。如果标识符已存在，那么对象环境记录会无视它，所以`var`可以重复声明。

2. 声明式环境记录：
- 存储变量、函数和参数。一个函数环境包含声明性环境记录。用于***记录标识符与变量的映射***，但是它***只记录非`var`声明的标识符***。声明式环境记录没有关联的绑定对象。
- 声明式环境记录会将所有的非`var`标识符实例化，但不初始化，变量处于`uninitialized`状态。也就是说内存中已经给已经给变量预留了空间，但没有和对应的标识符绑定关系。在`js`代码执行阶段，执行到声明语句时才会初始化绑定和赋值，这也是暂时性死区的原因。
- 在声明式环境记录中，不允许出现重复的标识符，甚至和`var`声明的标识符冲突。以上这些过程在代码加载后的预编译阶段就已经完成了。

### const特性
`const`声明与`let`基本相同，唯一一个重要的区别是`const`变量声明时必须初始化变量，且尝试修改`const`声明的变量会导致运行时报错。
以下是`MDN`对`const`声明的描述：

> `const`声明创建一个**值的只读引用**。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容。

**注意**

```js
const num = 3
num = 3  // 报错： Assignment to constant variable  

const arr = []
arr = arr // 报错： Assignment to constant variable.
```
上述代码都对标识符进行了重新分配，虽然分配的值或者地址没有发生改变。

## 箭头函数

### 箭头函数与普通函数区别
1. 箭头函数没有自己的`this`对象，而是引用外层最近普通函数的`this`。因此箭头函数使用`.call()`等硬绑定是无效的。
2. 不可以当做构造函数，对箭头函数使用`new`命令会报错。
3. 没有`arguments`对象，该对象在构造函数体内不存在。
4. 不能使用`yeild`命令，因此箭头函数不能用作`Generator`函数。
5. 箭头函数作为`class`类中的方法时，不会挂载到原型链上，而是作为类的一个属性而存在。
### 箭头函数特性本质
- 箭头函数没有`[[Constructor]]`这个内部槽。
- 函数对象是一个支持`[[Call]]、[[Contructor]]`内部方法的对象。每个支持``[[Construct]]``的对象必须支持``[[Call]]``，因此构造函数必须是函数对象。想要对某个对象使用`new`关键字，就得确保该对象具有`Contructor`方法，而箭头函数没有
- 箭头函数设计之初就是为了设计一种简短且不绑定`this`的函数。所以箭头函数不为参数`super`、`this`、或者`new.Target`定义本地绑定。箭头函数的这些参数由外层最近的普通函数决定。



## 解构赋值

- `es6` 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构
### 数组的解构
- 语法如下
```js
const [a, b, c] = [1, 2, 3]
console.log(a, b, c) // 1 2 3
```
- 按照对应的位置对变量进行赋值
- 这种写法称为**模式匹配**，只要等号两边模式相同，左边的变量就被赋予对应的值
- 如果右边数组中没有对应的值，则变量被赋值为 `undefined`
- 左边的模式可以是右边模式的子集，可以值匹配一部分值
- 拥有 `iterator` 接口的数据结构都可以用数组的形式结构，比如 `Set`
- 解构时左边变量可以赋默认值，如果与右边匹配不到就是用默认值，匹配到就被赋予右边对应的值
- 如果默认值是一个函数表达式，则是惰性赋值，不会立即执行，需要手动执行
### 对象的解构
- 语法如下
```js
const {a, b} = {a: 1, b: 2}
console.log(a, b)  // 1 2
```
- 与数组不同，对象的属性没有顺序，左边变量的值不由位置决定，必须与右边属性名同名才能成功赋值
- 结构失败赋值为 `undefined`
- 对象的解构赋值可以很方便地将现有对象的方法赋值到某个变量
- 对象的解构赋值也可以赋默认值
### 字符串的解构
- 语法如下：
```js
const [a, b, c, d, e] = 'hello'
console.log(a, b, c, d, e) // 'h' 'e' 'l' 'l' 'o'
```
- 解构时字符串被转化为了一个类似数组的对象
- 类似数组的对象都有一个`length`属性，因此还可以对这个属性解构赋值
```js
let {length : len} = 'hello'
console.log(len) // 5
```
### 数值和布尔值的解构
- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
```js
let { toString: s } = 123
console.log(s) // [Function: toString]
s === Number.prototype.toString // true
```
### 函数参数解构
- 函数的参数也可以使用解构赋值
```js
function add([x, y]){
  return x + y;
}
add([1, 2]) // 3
```
- 函数 `add` 的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量 `x` 和`y`
### 解构的用途
#### 交换变量的值
```js
let x = 1;
let y = 2;
[x, y] = [y, x]
```
#### 函数返回多个值
函数要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。
```js
function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();
```
#### 提取 JSON 数据
解构赋值对提取 `JSON` 对象中的数据，尤其有用。
```js
let jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
}
let { id, status, data: number } = jsonData
```
#### 函数参数设默认值
```js
obj.ajax = (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,) => {}
```
- 避免了在函数体内部再写 `var foo = config.foo || 'default foo` 这样的语句
#### 遍历 Map 结构
`Map` 结构原生支持 `Iterator` 接口，配合变量的解构赋值，获取键名和键值就非常方便。

```js
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}
// first is hello
// second is world
```
#### 模块化引入时解构
```js
import { Com1, Com2 } from './conponents'
const { fn1, fn2 } = require('./utils')
```
## Map && Set
- `Map` 和 `Set` 都是 `es6` 新提供的数据结构，可以通过`new`创建一个实例
### 字典 & 集合
- 集合：集合是由一组无排序且唯一(即不能重复)的项组成的，可以理解为一个没有重复项也没有排序的数组
- 字典：以 `[键, 值]` 对的形式存储数据项的数据结构，也是只能存储不重复项
- 字典集合都存储不重复的数据项
#### 哈希表
- 也叫散列表，根据键(`key`) 直接访问在内存存储位置的数据结构。
- 通过计算一个键值对的函数， 将所需查询的数据映射到表中一个位置来访问记录
- 映射函数称为**散列函数**，也叫 `hash` 函数；存放记录的数组叫散列表
- `hash`函数（散列函数）：将 `key` 转化为一个整型数字 -> 用该数字对数组长度取余 -> 取余结果作为下标访问数组 -> 得到 `value`
### Map
- 与 `Object` 对象类似，本质上都是键值对的集合，在数据结构就是**字典**
- `Object` 对象有缺陷，不能将引用数据类型作为键(`key`)，只能以 `String` 和 `Symbol` 作为键
- 实现了完整的 `hash` 结构，弥补了 `js` 中没有 `hash` 结构的缺陷
- `Map` 是构造函数，可以通过 `new Map()` 创建一个实例，可以传入**二元数组（`[[a, b]]`）**作为初始值
- 如果对同一个键多次赋值，后面的值将覆盖前面的值，因为 `Map` 保存不重复的数据项。
- 主要用途：用于数据存储
#### 键的相等
键的比较基于`sameValueZero`算法：
- `NaN` 与 `NaN` 相等，如果一个 `Map` 中有两个 `NaN` 作为键，后者将覆盖前者
- `+0 与 -0` 相等
- 其他所有的值都是根据 `===` 运算符的结果判断是否相等
#### 与 Object 的比较

| Map                                                          | Object                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `Map` 默认情况不包含任何键。只包含显式插入的键。             | 一个 `Object` 有一个原型, 原型链上的键名有可能与对象实例上的键名冲突。 |
| `Map` 的键可以是任意数据类型                                 | `Object` 的键必须是一个 `String` 或是 `Symbol`               |
| `Map` 中的 key 是有序的，迭代时 `Map` 对象以插入的顺序返回键值。 | `Object` 的键是无序的                                        |
| `Map` 的键值对个数可以轻易地通过 `size` 属性获取             | `Object` 的键值对个数只能手动计算                            |
| `Map` 是 `iterable` 的，可以直接被迭代。                     | `Object`需要以某种方式获取它的键然后才能迭代。               |

#### Map的属性和方法
##### 属性
- `map.size`：返回 `map` 中包含**键值对**的个数
##### 操作方法
- `map.set(key, value)`：添加新的键值对
- `map.get(key)`： 通过 `key` 查找对应的 `value` 并返回
- `map.has(key)`：查找 `map` 中是否存该 `key`，是返回 `true`，否则返回 `false`
- `map.delete(key)`：通过 `key` 移除该键值对
- `map.clear()`：将 `map` 中所有的元素删除
##### 迭代方法
`Map` 遍历的顺序就是键值对插入的顺醋，因为 `Map` 没有索引，所以不能使用普通 `for` 循环遍历。

- 可以 `for of` 遍历
- `map.keys()`：将 `map` 中所有键名以数组形式返回
- `map.values()`：将 `map` 中所有值以数组形式返回
- `map.forEach()`：回调遍历 `map` 所有成员，可接受第二个参数，用于绑定 `this`
- `map.entries()`：返回所有成员的遍历器，即 `Symbol.iterator`属性，在 `Map` 中该属性等同于键值对本身
```js
const arr1 = [1, 10],arr2 = [2, 20]
const map = new Map([arr1, arr2])
console.log(map.entries()) // [Map Entries] { [ 1, 10 ], [ 2, 20 ] }
for (let [key, value] of map.entries()) {
  console.log(key, value) // 1 10 | 2 20
}
```
##### Map转化
##### Map转数组
- 利用扩展运算符
```js
const map = new Map([
  [1, 10],
  [2, 20]
])
const arr = [...map]
console.log(arr) // [ [ 1, 10 ], [ 2, 20 ] ]
```
- `for of` 循环
```js
const map = new Map([
  [1, 10],
  [2, 20]
])
const arr = []
for (const [key, val] of map) {
  arr.push([key, val])
} 
console.log(arr) // [ [ 1, 10 ], [ 2, 20 ] ]
```
##### Map转Object
- 使用`forEach`
```js
const map = new Map([
  [1, 10],
  [2, 20]
])
const obj = {}
map.forEach((value, key) => {
  obj[key] = value
})
console.log(obj) // { '1': 10, '2': 20 }
```
- 利用 `Object.fromEntries()` 
```js
const map = new Map([
  [1, 10],
  [2, 20]
])
const obj = Object.fromEntries(map)
console.log(obj) // { '1': 10, '2': 20 }
```
### WeakMap
- 类似于 `Map`，也是键值对的集合，即字典结构
- `WeakMap` 的键必须是引用类型
- `WeakMap` 的键所引用的对象都是弱引用，当 `WeakMap` 中的键所指对象在其他地方没有被引用就会被垃圾回收掉
- 因为键是弱引用，所以其状态不可预测，所以 `WeakMap` 不可遍历，否则会得到不确定的结果
- `WeakMap` 提供的接口 与 `Map` 相同
##### WeakMap语法
- 键是弱引用，不提供遍历操作，也没有 `size` 属性。因为键名随时可能被垃圾回收掉，可能这一刻能取到键名，下一刻垃圾回收机制运行该键名就没了，为防止不确定性就规定不能取到键名。
- 不能清空，即不支持 `clear` 方法
- `WeakMap` 只有四个方法可用：`set()`、`get()`、`has()`、`delete()`
### Set
- `Set` 也是 `[键, 值]` 对结构，但是 `Set` 的键由值决定，并且键与值相等
- `Set` 本身是一个构造函数，可通过 `new Set()` 实例化，可以传入一个**一元数组（`[a, b, c]`）**作为初始值
- 可以作为数据去重的解决方案
- `NaN` 和 `undefined` 可以被存储在 `Set` 中
- 可使用扩展运算符展开
#### 值的相等
- `+0` 与 `-0` 相等
- `NaN` 与 `NaN` 相等，多个 `NaN` 会被视为相同的值
#### Set的属性和方法
##### 属性
`Set` 结构的实例有如下属性：
- `set.contructor()`：返回 `set` 的构造函数，默认就是 `Set` 构造函数
- `set.size`：返回 `set` 元素总数
##### 操作方法
- `set.add(val)`：向 `set` 中添加一个新的值 
- `set.delete(val)`：从 `set` 中删除一个值，根据删除是否成功返回 `true || flase`
- `set.has(val)`：判断 `set` 中是否存在 `val`，是就返回 `true`，否则返回 `flase`
- `set.clear()`：清空 `set` 中所有值
##### 遍历操作
`Set` 集合提供了四种遍历方法，可以遍历所有成员
- `set.keys()`：返回一个数组，包含 `set` 中所有键名
- `set.vaues()`：返回一个数组，包含 `set` 中所有值
- `set.forEach()`：使用回调函数遍历每个成员
-  `set.entries()`：返回所有成员的遍历器，即 `Symbol.interator`属性
##### Set转化为数组
- 遍历每个成员添加到空数组中
```js
const set = new Set([1, 2, 3]), arr = []
for (const val of set) {
  arr.push(val)
}
console.log(arr) // [ 1, 2, 3 ]
```
- `Array.from`
```js
const set = new Set([1, 2, 3])
console.log(Array.from(set)) // [ 1, 2, 3 ]
```
##### 利用Set数组去重
- `new Set()` 传入数组转化为 `Set` 在转化回数组
```js
const arr = [1, 2, 2, 3, 3, 3]
const set = new Set(arr)
const arr1 = Array.from(set)
console.log(arr1);
```
### WeakSet
- 引用类型的集合，相比于 `Set`，`WeakMap` 中的所有成员都必须是引用数据类型（任何具有 `Iterable`接口的对象 ）
- `WeakSet`，本身是构造函数，可通过 `new WeakSet` 创建实例 
- 保持弱引用，集合中对引用类型的引用是弱引用，如果没有被其他地方引用就会被垃圾回收掉
- 可以作为存储对象的容器，例如存储一个 `DOM` 节点对象，当该节点对象在其他地方没有被引用时就会被垃圾回收掉，这样就解决的 `DOM` 节点可能造成的内存泄露问题
##### WeakSet 语法
因为弱引用，`WeakSet` 状态不可预测，所以不提供可以遍历的方法。`WeakSet` 只有如下三个方法
- `weakset.add(val)`：添加一个新成员
- `weakset.delete(val)`：移除一个成员
- `weakset.has(val)`：判断成员是否存在于集合中，是就返回 `true`，否则返回 `false`
## Promise
- 异步函数的一种实现方式，解决了传统回调函数产生的回调地狱问题
- `Promise` 本身是构造函数，可以通过 `new Promise()` 创建实例
- `Promise` 提供统一的  `API`，各种异步操作都可以用同样的方法进行处理
- `Promise` 对象的状态不受外界影响
### 三种状态

![pending](C:\Users\21133\Pictures\js\pending.png)

- `pending`：等待中
- `fulfilled`：成功了，即 `resolve` 之后的状态
- `rejected`：失败了，即 `reject` 之后的状态
- 一旦状态改变，就不会再变，任何时候都可以得到这个结果
- `Promise` 对象的状态改变，只有两种可能：`pending --> fulfilled`和 `pending --> rejected `。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 `resolved`（已定型）。
- 如果状态已改变，再对 `Promise` 对象添加 `.then` 回调，也会立即得到这个结果。这与事件（`Event`）完全不同，事件的特点是：如果你错过了它，再去监听，是得不到结果的。
### 用法
- `Promise` 构造函数接受一个函数作为参数，该函数的两个参数分别是 `resolve` 和 `reject`函数。
```js
const promise = new Promise((resolve, reject) => {})
```
- `resolve()` 函数：将 `Promise` 由 `pending -> resolved(fulfilled)`，在异步操作成功时调用，并将异步操作的结果作为参数传递出去，之后的 `.then()` 可以拿到该参数
- `reject()`函数：将 `Promise` 由 `pending -> rejected`，在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去，之后的 `.catch()` 可以拿到该错误
- `resolve` 和 `reject` 都可以接受回调函数作为参数。`resolve` 还可以接受 `Promise` 对象作为参数。`reject` 一般接受 `Error` 实例对象作为参数。
```js
const promise = new Promise((resolve, reject) => {
    if (...) {
		resolv(() => {}) // 也可以传入新的 Promise 实例
    } else {
         reject(err)                 
    }
}) 
```
- `resolve` 如果接受新的 `Promise` 对象作为参数，那么原 `Promise` 就会等待新 `Promise` 对象的结果再从 `pending` 状态跳转到 `resolve` 或 `reject` 状态，后续的 `.then` 也会等待该结果
#### .then() 
- `.then()`：为 `Promise` 实例添加状态改变时的回调函数，接受两个回调函数作为参数。第一个回调函数是 `Promise` 对象的状态变为`resolved` 时调用。第二个回调函数是 `Promise` 对象的状态变为 `rejected` 时调用。这两个函数都是可选的，不一定要提供。它们都接受 `Promise` 对象传出的值作为参数。
- `.then` 方法返回的是一个新的 `Promise` 实例（注意，不是原来那个 `Promise` 实例）。因此可以采用链式写法，即 `then` 方法后面再调用另一个 `then` 方法。
- 传递到 `then()` 中的函数被置入到一个微任务队列中，而不是立即执行。
### .catch()
- `.catch()` 是 `.then(null, rejection)` 或 `.then(undefined, rejection)` 的别名，用于指定发生错误时的回调函数。
- `Promise` 对象的错误有冒泡性质，错误总是被最后的 `.catch()` 捕获
- `Promise` 内部的错误如果不用 `.catch()` 处理掉就不能传递到外部代码，外层代码不会因为 `Promise` 内部的错误而终止运行报错。
- `.catch()` 返回的是一个新的`Promise`对象，内部的回调还能再抛出错误，需要内部的 `.catch()` 捕获，外层的 `catch` 捕获不到
#### .finally()
- 返回一个新的 `Promise` 对象，无论结果是`fulfilled`或者是`rejected`，都会执行指定的回调函数
- 可以用来执行无论是 `.then()` 还是 `.catch()` 都需要执行的操作，避免在 `.then()` 和 `.catch()` 中写重复的代码
- `.finally()` 不接受任何参数
- 一个典型的应用场景就是在 `Promise` 结束后关闭服务器
### Promise三驾马车
- 接受一个可迭代对象（例如数组），数组中每个成员都是 `Promise` 实例
- 将多个 `Promise` 实例包装成一个新的 `Promise` 实例
#### promise.all()
- 当数组中所有 `Promise` 实例都成功时 `Promise.all()` 才成功，这些 `Promise` 的返回值组成一个数组传递给 `promise.all()` 的回调
- 数组中只要有一个 `Promise` 失败，`Promise.all()` 就失败，第一个 `reject` 的 返回值传递给 `Promise.all()` 的回调
#### promise.race()
- 数组中第一个 `Promise` 实例改变状态后， `promise.race()` 就立即改变状态，该 `Promise` 实例的返回值传递给 `promise.race` 的回调
#### promise.any()
- 数组中所有的 `Promise` 实例都失败 `promise.any()` 才失败
- 数组中第一个成功的 `Promise` 的实例的返回值传递给 `promise.any()` 的回调
## class类
`js` 中的 `class` 只是构造函数的**语法糖**，在语法上接近传统的类，弥补了 `js` 没有类设计模式的遗憾，并不是真正的类，本质上还是基于原型式继承的对象。

### 语法
```js
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  song() {

  }
  onFoot() {

  }
}
```
- `constructor`： 构造方法，初始化实例需要的初始状态，其中的 `this` 指向实例。通过 `new` 创建实例时，自动调用该方法。如果没有显示创建，默认添加空的 `constructor(){}`
- 为 `class` 类添加方法时不需要使用声明的关键字（`function`），多个方法也不能用逗号分隔
- 上面例子中，`constructor`、`song`、`onFoot`实际上都被挂载在了 `Person.prototype` 上，类的实例调用方法就是调用原型上的方法
### getter & setter
因为类是构造函数的语法糖，随意类内部也可以使用 `get` 和 `set` 关键字拦截属性的存取行为，以此实现类的私有变量。

## iterator
- `iterator` 是一种接口，也称为**遍历器对象**。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 `iterator` 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
- `iterator` 接口与数据结构是分开独立的，因此可以创建没有 `iterator` 的对象，也可以用 `iterator` 模拟例如 `Array、Set、Map`这样的数据结构。
- 一种数据结构只要部署了 `iterator` 接口，就称这种数据结构是**可遍历的**。
### iterator 的三个作用
1. 为各种数据结构，提供一个统一的、简便的访问接口。
2. 使得数据结构的成员能够按某种次序排列。
3. `ES6` 创造了一种新的遍历命令 `for...of` 循环，`Iterator` 接口主要供 `for...of` 消费。
### iterator 遍历过程
1. 创建一个指针对象，指向当前数据结构的起始位置。
2. 第一次调用指针的 `next` 方法，指针指向数据结构的第一个成员。
3. 第二次调用指针的 `next` 方法，指针指向数据结构的第二个成员。
4. 第 `n` 次调用指针的 `next` 方法，指针指向数据结构的第 `n` 个成员。
5. 不断调用 `next()` 方法，直到指针指向数据结构中的末尾。

每一次调用 `next` 方法，都会返回数据结构的当前成员的信息（一个包含`value` 和 `done` 两个属性的对象）。`value` 是当前成员的值，`done` 是一个布尔值，表示遍历是否结束。
### Symbol.iterator
- `iterator` 部署在数据结构的 `Symbol.iterator` 属性上。
- `Symbol.iterator` 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。
- 属性名 `Symbol.iterator` 是一个表达式，返回 `Symbol` 对象的 `iterator` 属性，这是一个预定义好的、类型为 `Symbol` 的特殊值，所以要放在方括号内（`[Symbol.iterator]`）。
- `Symbol.iterator` 的属性描述符：`writable: false; enumerable: false; configurable: flase`，也就是说 `Symbol.iterator` 是不可修改值、不可枚举、不可配置的。
```js
// 定义一个可遍历的Object对象
const obj = {
  a: 1,
  b: 2,
  [Symbol.iterator]: function () {
    const that = this
    let i = 0,
      k = Object.keys(that)
    return {
      next: function () {
        return {
          value: that[k[i++]],
          done: i > k.length
        }
      }
    }
  }
}

const itr = obj[Symbol.iterator]()
console.log(itr.next()) // { value: 1, done: false }
console.log(itr.next()) // { value: 2, done: false }
console.log(itr.next()) // { value: undefined, done: true }
```
- `Symbol.iterator + defineProperty` 
```js
const myObj = {
  a: 1,
  b: 2
}
Object.defineProperty(myObj, Symbol.interator, {
  enumerable: false,
  writable: false,
  configurable: true,
  value: function () {
    let that = this,
      i = 0,
      k = Object.keys(that)
    return {
      next: function () {
        return {
          value: that[k[i++]],
          done: i > k.length
        }
      }
    }
  }
})
const obj = myObj[Symbol.interator]()
console.log(obj.next()); // { value: 1, done: false }
console.log(obj.next()); // { value: 2, done: false }
console.log(obj.next()); // { value: [Function: value], done: true }
```
### 原生具有iterator接口的数据结构
- `Array`
- `Map`
- `Set`
- `String`
- 函数的 `arguments` 对象
### iterator调用的场合
- 解构赋值：对数组和 `Set` 解构赋值时默认调用 `Symbol.iterator` 方法。对象的解构赋值不会，因为 `Object` 默认没有 `iterator`接口
- 扩展运算符
- `yield`：`generator` 函数的 `yield` 默认调用 `Symbol.iterator` 方法
- `Array.from()`
- `for ... of`
- `Map(), Set(), WeakMap(), WeakSet()`
- `Promise.all()`
- `Promise.race()`
### return() & throw()
`iterator` 遍历器对象不仅有 `next()` 方法，还有 `return()` 和 `throw()` 方法。`next()` 方法是必须部署的，而 `return()` 和 `throw()` 是选择性部署的。

- `return()`：使遍历提前退出。在 `for ... of` 中，如果循环过程中出错或者遇到 `break`，就会触发 `return()` 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 `return()` 方法。
- `throw()`：`throw()` 方法主要是配合`Generator`函数使用。
## generator函数
- 全称**生成器**函数
- 声明方式：`function* fn() {}`，在 `function` 关键字后加上一个星号。
- `generator` 函数执行会返回一个 `generator` 对象（遍历器对象），该对象可以依次遍历 `generator` 对象的每个状态。
- `generator` 函数可以看做是一个状态机， 内部通过 `yield` 表达式定义多个状态。
### generator对象
- `generator` 对象是由 `generator` 函数返回的**迭代器（`iterator`）**对象。
- `generator` 对象有 `next()` 方法，调用该方法就可以使状态指针移向下一个状态。
#### next() 方法
- `generator`函数执行后调用`next()`方法。`next()`方法会将`generator`函数推进下一个状态。
- `next()` 方法返回一个对象，这个对象包含两个属性：`value` 和 `done`：
	- `value` ：表示本次 `yield` 表达式的返回值。
	- `done` ：布尔类型，表示生成器后续是否还有 `yield` 语句，即生成器函数是否已经执行完毕并返回。
- 调用 `next()` 方法时，如果传入了参数，那么这个参数会传给上一条执行的 `yield` 语句左边的变量。
### yield
- `yield`是一个表达式，用来定义 `generator` 函数内部状态。
- `yield`本身没有返回值（`undefined`），`yield`后面的值只是作为`generator`的一个状态，在`next()`执行后作为函数返回对象的`value`属性值。
- `generator`函数是分段执行的，`yield`表达式是暂停执行的标记，而`next`方法可以恢复执行。
### for ... of循环generator对象
- `generator`函数执行后生成的对象本质上就是`iterator`对象，因此支持`for ... of`循环
- `for ... of`循环只能遍历到 `yield` 表达式后面的值，`return`的值是遍历不到的。
```js
function* generator() {
  yield 1
  const num1 = yield 2
  console.log('nums1:' num1)
  const num2 = yield 3
  console.log('num2': num2)
  return 10
}

const gr = generator()
console.log(gr) // Object [Generator] {}
console.log(gr.next()) // { value: 1, done: false }
console.log(gr.next()) // { value: 2, done: false }  num1: 9
console.log(gr.next(9)) // { value: 3, done: false } num2: undefined
console.log(gr.next()) // { value: 10, done: false }
console.log(gr.next()) // { value: undefined, done: true }

for (const num of gr) {
  console.log(num) // 1 2 3 遍历不到 return 的 10
}
```
### 运行逻辑
1. 调用 `next()` 方法。
2. 遇到`yield`表达式就暂停后续操作，将该`yield`表达式后面的值作为返回对象的`value`的值（`{value: yieldVal, done； false}`）。
3. 下次调用`next()`方法，直到遇到下一个`yield`。
4. 过完最后一个`yield`，就一直运行到函数结束，最后`return`后面的值作为返回对象的`value`值。
5. 如果函数没有`return`，则调用`next()`直到过完最后一个`yiled`之后返回对象为：`{value: undefined, done: true}`。
### generator异步编程
- `es6` 之前，异步编程的方法有如下四种：回调函数、事件监听、发布/订阅、`Promise` 对象
- 回调函数会有回调地狱的问题，`Promsie`有语义不请的问题
#### 协程
协程的执行逻辑有点像线程
1. 协程 `A` 开始执行
2. 协程 `A` 执行到一半，执行权交给协程 `B`
3. 协程 `B` 执行一段时间后交还执行权
4. 协程 `A` 恢复执行
#### `generator`实现协程
- `generator`每次遇到`yield`就会暂停，交出执行权。
- 整个 `generator` 非常适合作为异步任务的容器，异步操作需要暂停的地方就使用`yield`标注。
## async await
- 本质上是`generator`函数的语法糖，一种处理异步编程的语法。
- `async`函数的返回值是一个`promise`。

## 扩展运算符

## decorator

## proxy

# node
## node如何解决异步问题
- 传统方法是使用回调函数，因此 `node` 是异步无阻塞的
- `sync` 方案，哪个文件加载好就先启用哪个文件，性能不好
- `promsie` 手动封装，`return new Promise()`
- `const fs = require('fs/promises')` 使用 `node fs/promises` 模块，有兼容性问题，`node` 14版本以上才兼容
- `util.promisify()`：接受一个异步操作的函数，返回一个返回值是 `Promise` 的函数。

## 中间件
### 中间件是什么
- 中间件是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。
- 对于`Web`应用而言，我们并不希望了解每一个细节性的处理工作，而是希望能够把主要精力集中在业务处理上，以达到提升开发效率的目的, 所以引入了中间件来简化和封装这些基础逻辑处理细节。
- node中间件本质上就是在进入具体的业务处理之前，先让特定过滤器处理。

## promisify
来自于`node`的`util`模块
```js
import { promisify } from 'node:util'
```
- `promisify`可以将`node`中普通的异步方法变成`promise`形式。

## koa
### 洋葱模型
## egg.js
### 数据库交互
#### 配置连接数据库
1. `config/plugin.js`启用数据库插件
```js
module.exports = {
  mysql: {
    enable: true,
    package: 'egg-mysql'
  }
}

```
2. `config/config.default.js`连接数据库
```js
config.mysql={
    // 数据库配置 
    client: {
      // host
      host: 'localhost',
      // port
      port: '3306',
      // username
      user: 'root',
      // password
      password: '19991022',
      // database
      database: 'react-blog',
    },
    // 是否加载到应用程序，默认为打开
    app:true,
    // 是否加载到代理中，默认值为“关闭”
    agent:false,
}
```
- `config.default.js`中的配置如果使用`config.xxx = {}`的方式声明的，可以不写`app: true`，`egg.js`会自动帮我们将这个配置挂载到`app`上。如果使用`export.xxx = {}`声明配置，就需要打开`app: true`，这样才能挂载到`app` 

#### 操作数据库api

1. `get`查找表中一条数据
```js
// 根据 username 查找 user 表中是否存在这条数据
const result = await app.mysql.get('user', { username })
```
2. `select`查找，第二个参数不写默认查询表中所有数据
```js
const result = await this.app.mysql.select('user', {
where: { username }
})
```
3. `insert`新增数据
```js
// 向 user 表中插入一条用户数据
const result = await this.app.mysql.insert("user", {username: "huajiya2", password: "1234"})
```
4. `query` 执行 `sql` 语句
```js
// 声明 sql 查询 user 表中用户名密码的语句
const sql = " SELECT username FROM user WHERE username = '" + username + "' AND password = '" + password + "'"
// 执行语句查询
const res = await this.app.mysql.query(sql)
```
5. `update` 修改数据
```js
// 根据主键 id 修改数据
const result = await this.app.mysql.update('user', { id: 2, username: '赵四' })
// 使用 `sql` 语句修改
const results=await this.app.mysql.query('update user set username = ? where id = ?', ["王五", 2])
```
6. `delete` 删除数据
```js
// 删除 user 表中 id 为3的那条数据
const result = await this.app.mysql.delete('user', { id: 3 })
```
7. `sql` 事务
```js
const conn = await this.app.mysql.beginTransaction()
try{
    await conn.insert('user',{'username':'xiao1','password':'1111'})
    await conn.update('user',{id: 2, username: '黑子'})
    await conn.commit()  //提交事务
}catch(err){
    await conn.rollback() //回滚事务
    throw err
}
```


# react	

## react哲学（原则）

### 数据流

#### react自身数据流

- `react` 数据流是自上而下的单向绑定数据流
- 容器组件负责处理业务逻辑和数据
- 展示组件负责 `UI` 展示，通常展示组件抽离出去进行封装以便复用

### react套件

- `react + react-dom`：解决组件化还有组件挂载的问题
- `react-router-dom`：负责前端路由的配置，实现单页应用（`SPA`）
- `redux + react-redux`：数据流管理，吸光所有的组件的状态，组件自有状态越少越好，状态抽离出去交给 `redux` 统一管理

##### 组件通信

-  组件之间通信通过父子组件来实现，父组件将状态和数据通过 `props` 传递给子组件
-  兄弟组件通信需要有共同的父组件
-  `context` 出现后可以跨层级传递状态，
   - `createContext + useContext`。`const myContext = createContext(data)` 创建执行上写文
   - `<myContext.Provider></myContext.Provider value={data}>`就可以作为高层组件向下传递状态，需要传递的数据都放在 `value` 属性中
   - `const data = useContext(myContext)` 可以将 `data` 从 `value` 中解构出来

##### react自身数据流缺点

- 逻辑写在组件中，组件变得臃肿
- 状态难以预知并且不可回溯，因为一个事件可能触发一系列的 `setState`
- 处理异步数据流的方案单一，只有 `setState` 或者 `useState + useEffect`，难以满足需求

#### redux

- `store`：提供了一个全局的 `store` 变量，用来存储从组件内部抽离出去的公用的状态
- `action`：提供了一个普通对象，用来记录我们每一次的状态变更，可日志打印与调试回溯，并且这是唯一的途径
- `reducer`：提供了一个纯函数，用来计算状态的变更
- 状态持久化：`globalstore` 可以保证组件就算销毁了也依然保留之前状态
- 状态可回溯：每个 `action` 都会被序列化，`Reducer` 不会修改原有状态，总是返回新状态，方便做状态回溯
- 使用纯函数，输出完全依赖输入，没有任何副作用
- 中间件：使用中间件做异步数据处理，对负责业务场景适应性更好

##### redux缺点

- 笨重：有繁重的代码模板，修改一个 `state` 可能要动四五个文件
- `store` 里状态残留：多组件共用 `store` 里某个状态时要注意初始化清空问题
- 无脑的发布订阅：每次 `dispatch` 一个 `action` 都会遍历所有的 `reducer`，重新计算`connect`，这无疑是一种损耗
- 交互频繁时会有卡顿：如果 `store` 较大，且频繁地修改 `store`，会明显看到页面卡顿；

## react设计理念
> `React`是用`JavaScript`构建**快速响应**的大型`Web`应用程序的首选方式

快速响应是关键，日常使用`app`或上网制约快速响应的因素：
1. 遇到大计算量的操作或设备性能不足导致页面掉帧（CPU的瓶颈）
2. 网络请求不能及时得到响应造成阻塞（IO的瓶颈）
### CPU瓶颈
1. **GUI渲染线程**与**JS线程**是互斥的。所以**JS脚本执行**和**浏览器布局、绘制**不能同时执行。
2. 主流浏览器刷新频率一般是60Hz，（1000ms/60Hz）大约16.6ms刷新一次，如果js执行时间过长，超出了16.6ms，这次刷新就没有时间执行**样式布局**和**样式绘制**了
3. **解决CPU瓶颈问题**：在浏览器刷新的每一帧时间中，预留一些时间给`js`线程，`react`利用这部分时间更新组件。`react`源码中这个时间大概是5ms。如果预留的时间不够用，`react`会将线程控制权还给浏览器渲染`UI`，`js`任务则等到下一帧继续被中断的工作。这种将长任务分拆到每一帧中，每次执行一小段任务的操作被称为**时间切片**。
- 时间切面的关键：将**同步更新**变成**可中断的异步更新 **。
### IO瓶颈
网络延迟是前端开发者无法解决的，前端需要做到的是：减少用户对网络延迟的感知。

`react`的解决方案是：在用户点击操作发生网络请求时，让当前页面先停留了一小段时间，这一小段时间用来请求数据。

`react`实现了`Suspense`功能以及配套的`hook（useDefredValue）`，为了支持这些特性，`react`在源码内部同样需要将**同步更新**变为**可中断的异步更新**。
## react架构
### V15老架构
`react15`架构可以分为两层：
- `Reconciler（协调器）`—— 负责找出变化的组件。
- `Renderer（渲染器）`—— 负责将变化的组件渲染到页面上。
`react15`架构不能满足**快速响应**的理念，于是重构了。
#### Reconciler（协调器）
`react`可以通过`this.setState、this.forceUpdata、ReactDOM.render`等api触发更新，每次更新时，`Reconciler`会做如下工作：
1. 调用组件的`render`方法，将返回的`jsx`转化为虚拟`DOM`
2. 将虚拟`DOM`和上次更新时的虚拟`DOM`对比
3. 通过对比找出本次更新变化的虚拟`DOM`
4. 通知`Renderer`将变化的虚拟`DOM`渲染到页面上
#### Renderer（渲染器）
`react`支持跨平台，不同平台有不同的`Renderer`。浏览器环境渲染的`Renderer`是`ReactDOM`。除此之外还有：
- `ReactNative`渲染器，渲染App原生组件
- `ReactTest`渲染器，渲染出纯js对象用于测试
- `ReactArt`渲染器，渲染到`Canvas、SVG、VML(IE8)`

在每次发生更新时，`Renderer`接收到`Reconciler`通知，将变化的组件渲染在当前宿主环境。
#### react15架构缺点
在`Reconciler`中，`mount`的组件会调用`mountComponent`，`updata`的组件会调用`upDataComponent`，这两个方法都会递归更新子组件。

`react15`的缺点主要就是递归更新的缺点：更新一旦开始就无法中断，如果层级很深，递归更新时间超过了16ms，就会造成掉帧、卡顿。

`Reconciler`和`Renderer`是交替执行的，一旦更新过程中发生异常导致更新中断，`react`就会将更新不完全的`DOM`渲染出来。
### V16新架构
`react16`架构可以分为三层（比`V15`多了一层）：
- `Scheduler（调度器）`—— 调度任务的优先级，高优先级任务先进入`Reconciler`
- `Reconciler（协调器）`—— 负责找出变化的组件。
- `Renderer（渲染器）`—— 负责将变化的组件渲染到页面上。
#### Scheduler（调度器）
上述`CPU`瓶颈解决方案是在浏览器的每一帧中预留一些时间给`js`线程，那么浏览器是否有剩余时间就作为任务中断的标准，所以我们需要一种机制——当浏览器有剩余时间时通知`react`。

部分浏览器实现了这个`api`—— `requestIdleCallback`，但这个`api`有缺点：
1. 浏览器兼容性
2. 触发频率不稳定，受到很多因素影响。例如浏览器切换一个`tab`后，之前注册的`tab`的`requestIdCallback`触发频率就会变得很低。

介于以上原因，`react`实现了功能完备的`api`，就是`Scheduler`。除了在浏览器空闲时间触发回调的功能，`Scheduler`还提供了很多调度优先级任务设置。
#### Reconciler（协调器）
`react15`是递归处理虚拟`DOM`的，而`react16`从递归变成了可以中断的循环过程（迭代），每次循环都会调用`shouldYield`判断当前是否有剩余时间。

解决中断更新`DOM`渲染不完全问题：`react16`中，`Reconciler`和`Renderer`不再是交替工作。当`Scheduler`将任务交给`Reconciler`后，`Reconclier`会为变化的虚拟`DOM`做标记（增/删/改）：
```js
	export const Placement = /*             */ 0b0000000000010
    export const Update = /*                */ 0b0000000000100
    export const PlacementAndUpdate = /*    */ 0b0000000000110
    export const Deletion = /*              */ 0b0000000001000
```
整个`Scheduler`与`Reconciler`的工作都在内存中进行。只有当所有组件完成`Reconciler`工作后才会交给`Recderer`。

`Reconciler`内部采用了`Fiber`架构
#### Renderer（渲染器）
`Renderer`根据`Reconciler`为虚拟`DOM`打的标记，同步执行对应的`DOM`操作。

### jsx
`jsx`是一种描述当前组件内容的数据结构，他不包含组件`schedule`、`reconcile`、`render`所需要的相关信息。

例如以下信息就不会包含在`jsx`中：
- 组件在更新中的优先级
- 组件的`state`
- 组件被打上的用于`Renderer`的标记

这些内容都包含在`fiber`节点中

`jsx`与`fiber`的关系：
> 在组件`mount`时，`Reconciler`根据`jsx`描述的组件内容生成组件对应的`fiber`节点。
> 在`updata`时，`Reconciler`将`jsx`与`fiber`节点保存的数据对比，生成组件对应的`fiber`节点，并根据对比结果为`fiber`节点打上标记。

## Fiber架构
`fiber`是什么？中文翻译叫做**纤程**，是**协程**的一种实现，在`js`中，**协程**的实现就是`generator`。

`react fiber`：`react`内部实现的一套状态更新机制。支持任务多种**优先级**，可中断与恢复，并且状态回复后可以复用之前的中间状态。其中每个任务更新单元是`react element`对应的`fiber`节点。

`react`中的虚拟`DOM`正式名称就叫做`Fiber`，虚拟`DOM`节点对应着`Fiber`节点。

### Fiber实现原理
#### Fiber的含义
1. 从架构层面理解：`react15`的`Reconciler`是递归执行的，数据保存在递归调用栈中，被称为`stack Reconciler`。`react16`的`Reconciler`基于`Fiber`实现，被称为`Fiber Reconciler`。
2. 从数据结构理解：`Fiber`是静态数据结构，每个`Fiber`节点对应一个`react element`，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的`DOM`节点等信息。
3. 从工作单元理解：`Fiber`是动态的工作单元，每个`Fiber`节点保存了本次更新中组件改变的状态、要执行的工作（删除/插入页面/被更新...）

#### Fiber的结构
```js
// fiber节点的结构
function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) {
  // 作为静态数据结构的属性
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

 // ...... 还有许多属性
}
```
`Fiber`节点属性很多，也可以分成三层含义理解。
1. 架构层面理解：每个`fiber`节点都有对应的`react element`，多个`fiber`节点靠如下三个属性连接成树：
```js
// 指向父级fiber节点
this.return = null
// 指向子fiber节点
this.child = null
// 指向右边第一个兄弟fiber节点
this.sibling = null
```
为什么父节点叫做`return`？—— `fiber`节点执行完`completeWork`会返回下一个节点。子`fiber`节点及其兄弟节点完成工作后会返回父节点，所以用`return`代指父节点。
2. 从数据结构层面理解：`fiber`作为静态的数据结构，保存了组件相关的信息：
```js
// `fiber`对应的组件类型 Function/Class/Host
this.tag = tag
// key 属性
this.key = key
// fiber 对应的真实 DOM 节点
this.stateNode = null
// ...
```
3. 从动态工作单元层面理解：作为动态的工作单元，`fiber`保存了本次更新的相关信息。
```js
// 保存本次造成更新的状态改变相关信息
this.pendingProps = pendingProps
this.memoizedProps = null
this.updataQueue = null
// ...

// 保存本次更新会造成的DOM操作
this.effectTap = NoEffect
this.nextEffect = null
this.firstEffect = null
this.lastEffect = null
```

保存调度优先级相关信息的两个字段
```js
this.lanes = Nolanes
this.childLanes = Nolanes
```
### Fiber工作原理
双缓存：在内存中构建并直接替换的技术
#### 双缓存fiber树
`react`最多同时存在两棵`fiber`树：
1. `current fiber`树：当前屏幕上显示内容对应的`fiber`树。
2. `workInProgress`树：正在内存中构建的`fiber`树。

`current fiber`树的`fiber`节点称为`current fiber`，`workInProgress fiber`的`fiber`节点称为`workInProgress fiber`，它们通过`alternate（备用）`属性连接。
```js
currentFiber.alternate === workInProgressFiber
workInProgressFiber.alternate === currentFiber
```

`react`应用的根节点通过让`current`指针在不同的`fiber`树的`rootFiber`之间切换来完成`current Fiber`树指向的切换 —— 当`workInProgress Fiber`树构建完成交给`Renderer`渲染在页面上后，应用根节点的`current`指针指向`workInProgress Fiber`树，`workInProgress Fiber`树就变成了`current Fiber`树。每次状态更新都会产生新的`workInProgress Fiber`树，通过`current`与`workInProgress`的替换，完成`DOM`更新。

## Fiber构建流程
`fiber`节点创建是在`render`阶段。这一阶段是由`Reconciler`处理的。

当`react`程序启动时，`ReactDOM.render`会创建`fiberRootNode`（源码中叫 `fiberRoot`）和`rootFiber`。`fiberRootNode`是整个应用的根节点，`rootFiber`是`<App>`所在组件的根节点。这样区分的目的是：应用中可以多次调用`ReactDOM.render`渲染不同的组件树，它们拥有不同的`rootFiber`。而整个应用的根节点只有一个，就是`fiberRootNode`。
### render阶段
大致流程：`(performSyncWorkOnRoot -> (workLoopSync -> (beginWork -> (reconcileChildren)) -> completeWork))`

当`performSyncWorkOnRoot`或者`performConcurrentWorkOnRoot`方法调用时，`render`阶段就开始了。这两个方法中分别会调用两个方法 —— `workLoopSync`和`workLoopConcurrent`：
```js
// performSyncWorkOnRoot会调用该方法
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress)
  }
}

// performConcurrentWorkOnRoot会调用该方法
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield) {
    performUnitOfWork(workInProgress)
  }
}
```
这两个方法唯一的区别是`workLoopConcurrent`会调用`shouldYield`方法判断浏览器是否有剩余时间，如果浏览器当前帧没有剩余时间就会终止循环，直到浏览器有空闲时间扣再继续遍历。

`workInProgress`代表当前已创建的`workInProgress fiber`。`performUnitOfWork`方法会创建下一个`fiber`节点并赋值给`workInProgress`，并将`workInProgress`与已创建的`fiber`节点连接起来`fiber`树。

`performUnitOfWork`的工作可以分成两个部分：**递** 和 **归**
1. 递阶段：从`rootFiber`开始向下深度优先遍历。为遍历到的每个`fiber`节点调用`beginWork`方法，该方法会根据传入的`fiber`节点创建子`fiber`节点，并将这两个`fiber节点`连接起来。当遍历到叶子节点（没有子组件的组件）时就会进入 归 阶段。
2. 归阶段：从叶子节点开始，调用`completeWork`处理`fiber节点`。当某个`fiber`节点执行完`completeWork`，如果存在 `兄弟fiber节点`（`fiber.sibling !== null`），就会进入 `兄弟fiber节点`的**递**阶段。如果不存在`兄弟fiber`，就会进入`父级fiber`的**归**阶段。
3. 递 和 归阶段会交替执行直到“归”到`rootFiber`，到此`render`阶段工作就结束了。
4. 另外，对于`<span>hello<span>`这样的单一文本子节点`fiber`，`react`会做特殊处理以达到性能优化的目的，而不是直接进入到递归流程。
	
#### beginWork
`beginWork`的工作是传入`当前fiber节点`，创建`子fiber节点`，并给生成的`fiber节点`赋予`effectTag（DOM节点操作的具体类型）`
```ts
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renserLanes: Lanes
): Fiber | null {//...}
```
`beginWork`函数接受三个参数：
1. `current`：当前组件对应的`fiber节点`在上次更新时的`fiber节点`，也就是`workInProgress.alternate`。
2. `workInProgress`：当前组件对应的`fiber节点`。
3. `renderLanes`：优先级相关。

根据双缓存机制，组件`mount`是首次渲染，不存在上次更新的`fiber`节点，此时`current === null`。 组件`update`时，`current !== null`。因此可以根据`current`是否等于`null`来判断组件是出于`mount`还是`updata`。

综上所述，`beginWork`的工作可以分为两部分：
1. `mount`时—— 除`fiberRootNode`外，`current === null`。会根据`fiber.tag`创建相应类型的`子fiber节点`。
2. `updata`时：如果`current`存在，在满足一定条件下可以复用`current`节点，这样就能克隆`current.child`作为`workInProgress.child`，而不需要新建`workInProgress.child`。

对于常见的组件类型（`FunctionComponent/ClassComponent/HostComponent`），最终都会进入到`reconcileChildren`方法进行处理。

##### reconcileChildren
`Reconciler`模块的核心部分。该方法作用如下：

1. 对于`mount`组件，他会创建新的`子fiber节点`。
2. 对于`updata`组件，它会将当前组件与该组件上次更新时对应的`fiber`节点进行比较（`diff`算法），将比较的结果生成新的`fiber节点`。
```ts
export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderLanes: Lanes
) {
  if (current === null) {
    // 对于mount的组件
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    // 对于update的组件
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
```
`reconcileChildren`方法也是通过`current === null?`区分`mount`与`updata`。不论走哪个逻辑，最终都会生成新的`子fiber节点`赋值给`workInProgress.child`，该`子fiber节点`作为本次`beginWork`的返回值并作为下次`performUnitOfWork`执行时`workInProgress`的传参。

`mountChildFibers`和`reconcileChildFibers`方法的逻辑基本一致，唯一区别就是`reconcileChildFibers`会为生成的`fiber节点`带上`effecTag`属性。

##### eggecTag
`render`阶段的工作是在内存中进行的，当工作结束后会通知`Renderer`（渲染器）需要执行的`DOM`操作。要执行`DOM`操作的具体类型就保存在`fiber.effecTag`中。

`effectTag`是二进制数字，可以方便地使用位操作为`fiber.effecTag`赋值多个`effect`。

```ts
// DOM 需要插入到页面中
export const Placement = 		  0b00000000000010
// DOM 需要更新
export const Updata =    		  0b00000000000100
// DOM 需要插入到页面中并更新
export const PlacementAndUpdate = 0b00000000000110
// DOM 需要删除
export const Deletion = 		  0b00000000001000
```
如果要通知`Renderer`将`fiber节点`对应的`DOM`节点插入到页面中，需要满足两个条件：
1. `fiber.stateNode`存在，也就是`fiber节点`中保存了对应的`DOM`节点。
2. `(fiber.effectTag & Placment) !== 0`，也就是`fiber节点`存在`Placement effectTag`。

首屏渲染如何完成？
1. `fiber.stateNode`会在`completeWork`中创建
2. `mount`时只有`rootFiber`会赋值`Placement effectTag`，在`commit`阶段只会执行一次插入操作。如果`mountChildFibers`也会赋值`effectTag`，那么`mount`时整棵`fiber`树所有节点都会有`Placement effectTag`，`commit`阶段再执行`DOM`操作时每个节点都会执行一次插入操作，这样的`DOM`操作是及低效的。

##### beginWork流程图

<img src="C:\Users\21133\Pictures\js\fiber-beginwork.png"  />

#### completeWork
类似`beginWork`，`completeWork`也是针对不同`fiber.tag`调用不同的处理逻辑。

作用：在上一个节点`diff`完成后对其进行收尾工作，表现是给有`effectTag`的`fiber`节点做相应的工作。

和`beginWork`一样，`completeWork`根据`current === null ?`判断是`mount`还是`update`。以处理`HostComponent`为例理解`completeWork`工作流程。

处理`HostComponent`
- `HostComponent`是原生`DOM`组件对应的`fiber`节点。
- 针对`HostComponent`，判断`updata`时还需要考虑`workInProgress.stateNode != null?`，也就是该`fiber`节点是否存在对应的`DOM`节点。判断完后就会进行`update`或`mount`。

##### update
`updata`时，不需要生成`DOM`节点，需要做的是处理`props`，例如：
1. 注册`onClick、onChange`等回调函数
2. 处理`style prop`
3. 处理`DANGEROUSLY_SET_INNER_HTML prop`
4. 处理`children prop`

这里最主要的逻辑是调用`updateHostComponent`方法：
```ts
if (current !== null && workInProgress.stateNode != null) {
  // update的情况
  updateHostComponent(
    current,
    workInProgress,
    type,
    newProps,
    rootContainerInstance,
  );
}
```
在`updateHostComponent`内部，被处理完的`props`会被赋值给`workInProgress.updateQueue`，并最终会在`commit`阶段被渲染在页面上。

##### mount
`mount`时的主要逻辑包括三个：
1. 为`fiber节点`生成对应的`DOM节点`
2. 将子孙`DOM`节点插入刚生成的`DOM节点`中
3. 与`update`逻辑中的`updateHostComponent`类似的处理`props`过程。

在`beginWork`中，`mount`只会在`rootFiber`存在`Placement effectTag`时发生，`commit`阶段如何通过一次插入`DOM`操作将整棵`DOM`树插入到页面中？—— `completeWork`中有一个`appendAllChildren`方法，该方法每次调用时都会将已生成的子孙`DOM`节点插入当前生成的`DOM节点`下。当**归**到`rootFiber`时，就有一个构建好的离屏`DOM`树。

##### effectList
作为`DOM`操作的依据，`commit`阶段需要找的所有的`effectTag`的`fiber`节点并依次执行`effectTag`操作。这种遍历在`render`阶段已经执行过一次了，如果`commit`阶段又遍历一次，就很低效。以下是`react`中这个问题的解决方法：

- 在`completeWork`的上层函数`completeUnitOfWork`中，每个执行完`completeWork`且存在`effectTag`的`fiber`节点都会被保存在一条名为`effectList`的链表中。
- `effectList`中第一个`fiber节点`保存在`fiber.firstEffect`，最后一个节点保存在`fiber.lastEffect`。这样在`commit阶段`只需要遍历`effectList`就能执行所有`effect`。
- 到这里`render`阶段的工作就全部完成了，在`performSyncWorkOnRoot`函数中`fiberRootNode`被传递给`commitRoot`方法，开启`commit`阶段工作流程。

##### completeWork流程图

![](C:\Users\21133\Pictures\js\fiber-completeWork.png)

### commit阶段
`commit`阶段是`Renderer`的主要工作。

`commitRoot()`方法是`commit`阶段工作的起点，`fiberRootNode（fiber树的根节点）`会作为传参
```ts
commitRoot(root)
```
在`rootFiber.firstEffect`上保存了一条需要执行**副作用**的`fiber节点`的单向链表`effectList`。这些`fiber`节点的`updataQueue`中保存了变化的`props`。这些**副作用**对应的`DOM`操作在`commit`阶段执行。此外，一些生命周期钩子（`componentDidxxx`）、`hook（useEffect）`也需要在`commit`阶段执行。

`commit`阶段的主要工作也就是`Renderer（渲染器）`的工作，其流程分为三个部分：
1. `before mutation`阶段——执行`DOM`操作之前
2. `mutation`阶段——执行`DOM`操作
3. `layout`阶段——执行`DOM`操作后

在`before mutation`阶段之前和`layout`阶段之后还有一些额外工作。涉及到比如`useEffect`的触发、优先级相关的重置、`ref`的绑定/解绑。
- `before mutation`之前主要做了一些变量赋值、状态重置的工作。
- `layout`之后做了`useEffect`相关的处理；性能追踪，追踪`react`渲染时间、性能等。

#### before mutation阶段
`before mutation`阶段会遍历`effectList`，依次执行如下操作：
1. 处理`DOM`节点渲染/删除后的`auFocus`（焦点）、`blur`（模糊）逻辑
2. 调用`getSnapshotBeforeUpdate`生命周期钩子
3. 调度`useEffect`

`before mutation`阶段代码较短，整个过程就是遍历`effectList`并调用`commitBeforeMutationEffects`函数处理。
```ts
// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级
const previousLanePriority = getCurrentUpdateLanePriority();
setCurrentUpdateLanePriority(SyncLanePriority);

// 将当前上下文标记为CommitContext，作为commit阶段的标志
const prevExecutionContext = executionContext;
executionContext |= CommitContext;

// 处理focus状态
focusedInstanceHandle = prepareForCommit(root.containerInfo);
shouldFireAfterActiveInstanceBlur = false;

// beforeMutation阶段的主函数
commitBeforeMutationEffects(finishedWork);

focusedInstanceHandle = null;
```

##### commitBeforeMutationEffects方法
`commitBeforeMutationEffects` 方法是`before mutation`阶段的主函数，源码如下：
```ts
function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    const current = nextEffect.alternate;

    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      // ...focus blur相关
    }

    const effectTag = nextEffect.effectTag;

    // 调用getSnapshotBeforeUpdate
    if ((effectTag & Snapshot) !== NoEffect) {
      commitBeforeMutationEffectOnFiber(current, nextEffect);
    }

    // 调度useEffect
    if ((effectTag & Passive) !== NoEffect) {
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalSchedulerPriority, () => {
          flushPassiveEffects();
          return null;
        });
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
```
`commitBeforeMutationEffects`作用可以分成三个部分：
1. 处理`DOM`节点渲染/删除后的`autoFocus（自动聚焦）`、`blur（模糊处理）`逻辑。
2. 调用`getSnapshotBeforeUpdate`声明周期钩子。
3. 调用`useEffect`。

###### 调用getSnapshotBeforeUpdate
从`react16`开始，`componentWillxxx`钩子前面增加了`UNSAFE_（不安全的）`前缀。

因为`Stack Reconciler`重构为`Fiber Reconciler`后，`render`阶段的任务可能中断或重新开始，对应的组件在`render`阶段的生命周期钩子（也就是`conponentWillxxx`）可能触发多次。这种行为和`react15`不一致，所以标记为`UNSAFE_`

`getSnapshotBeforeUpdate`是作为替代的声明周期钩子，触发时机是`commit阶段`内的`before mutation`阶段，由于`commit`阶段是同步的，所以不会遇到多次调用的问题。

###### 调用useEffect
在`scheduleCallback()`函数中会调度`useEffect`，`scheduleCallback()`方法用于某个优先级异步调度一个回调函数，这里就是异步调度`useEffect`。该函数由`Scheduler`提供。

`useEffect`如何被异步调度？分三步：
1. `before mutation`阶段在`scheduleCallback`中调度`flushPassiveEffects`
2. `layout`阶段之后将`effectList`赋值给`rootWithPendingPassiveEffects`
3. `scheduleCallback`触发`flushPassiveEffects`，`flushPassiveEffects`内部遍历`rootWithPendingPassiveEffects`

为什么需要异步调用`useEffect`？
> 与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。

***综上所述，同步执行会阻塞浏览器渲染，`useEffect`异步执行的原因主要是为了防止阻塞浏览器渲染。***

#### mutation阶段
`mutation`阶段执行`DOM`操作。类似于`before mutation`阶段，`mutation`阶段也会遍历`effectList`，执行函数`commitMutationEffects()`：
```js
nextEffect = firstEffect;
do {
  try {
      commitMutationEffects(root, renderPriorityLevel)
    } catch (error) {
      invariant(nextEffect !== null, 'Should be working on an effect.');
      captureCommitPhaseError(nextEffect, error);
      nextEffect = nextEffect.nextEffect;
    }
} while (nextEffect !== null)
```

##### commitMutationEffects()
`commitMutationEffects()`函数会遍历`effectList`，对每个`fiber`节点执行如下操作：
1. 根据`contentReset EffectTag`重置文字节点
2. 更新`ref`
3. 根据`effectTag`分别处理，`effectTag`有四种类型，`Placement | Update | Deletion | Hydrating`

###### Placement effect
当`fiber`节点中含有`Placement effect`，意味着该`fiber`节点对应的`DOM`节点需要插入到页面中。该操作调用的方法是`commitPlacement`。

`commitPlacement`方法的工作分为三步：
1. 获取父级`DOM`节点
2. 获取`fiber`节点的`DOM`兄弟节点
3. 根据`DOM`兄弟节点是否存在执行`DOM`插入操作

###### Update effect
当`fiber`节点含有`Update effectTag`，意味着该`fiber`节点需要更新。调用的方法为`commitWork`，他会根据`fiber.tag`分别处理。

当`fiber.tag`为`FunctionComponent`，会调用`commitHookEffectListUnmount`方法，该方法会遍历`effectList`，执行所有`useLayoutEffect()`的销毁函数。也就是其中`return`的函数。

当`fiber.tag`为`HostComponent`，会调用`commitUpdate`方法。最终会在`updateDOMProperties`中将`render`阶段`completeWork`中为`Fiber`节点赋值的`updateQueue`对应的内容渲染在页面上。

###### Deletion effect
当`Fiber`节点含有`Deletion effectTag`，意味着该`Fiber`节点对应的`DOM`节点需要从页面中删除。调用的方法为`commitDeletion`。该方法会执行如下操作：
1. 递归调用`fiber`节点及其子孙`fiber`结点中`fiber.tag`为`ClassComponent`的`conponentWillUnmount`声明周期钩子，从页面中移除`fiber`节点对应的`DOM`节点。
2. 解绑`ref`
3. 调度`useEffect`的销毁函数

#### layout阶段
该阶段的代码都是在`DOM`渲染完成，也就是`mutation`阶段完成后执行的。该阶段触发的生命周期钩子和`hooks`可以直接访问到已经改编后的`DOM`，即该阶段是可以参加`DOM layout`的阶段。

与前两个阶段相似，`layout`阶段也是遍历`effectList`执行函数，具体执行的是`commitLayoutEffects`。

`commitLayoutEffects`一共做了两件事：
1. 调用`commitLayoutEffectOnFiber()`方法（调用生命周期钩子和`hooks`相关操作）
2. 调用`commitAttachRef`（赋值`ref`）

## Diff算法
`diff`算法的作用：在`beginWork`中对于`update`的组件，`diff`算法会将当前组件在上次更新时对应的`fiber`节点比较，将比较的结果生成新的`fiber`节点。

一个`DOM`节点时再某一时刻最多会有四个节点与它相关：
1. `current fiber`，如果该`DOM`节点已在页面中，`current fiber`代表该`DOM`节点对应的`fiber`节点。
2. `workInProgress Fiber`，如果`DOM`节点将本次更新渲染到页面中，`workInProgress Fiber`代表`DOM`节点对应的`fiber`节点。
3. `DOM`节点本身。
4. `jsx`对象

***`diff`算法的本质是对比1和4，得到2，也就是对比`current fiber`和`jsx`生成`workInProgress Fiber`***

`Diff`的瓶颈以及应对方法：
`diff`算法本身也是有性能损耗的，即使在最前沿的算法中，将前后两棵树完全对比的算法的时间复杂度为`O(n^3)`，其中`n`是树中元素的数量。

为了降低算法复杂度，`react`的`diff`会预设三个限制：
1. 只对同级元素进行`diff`。如果一个`DOM`节点在前后两次更新中跨越了层级，`react`就不会去尝试复用它。
2. 两个不同类型的元素会产生不同的树。如果元素`div` 变成`p`，`react`会销毁`div`及其子孙节点，并新建`p`及其子孙节点。
3. 开发者可以通过`key prop`来暗示哪些子元素在不同的渲染下能保持稳定。

一段`demo`如下：
```html
// 更新前
<div>
  <p key="ka">ka</p>
  <h3 key="song">song</h3>
</div>

// 更新后
<div>
  <h3 key="song">song</h3>
  <p key="ka">ka</p>
</div>
```
如果没有`key`，`react`会认为`div`的第一和第二个子节点类型发生了变化，这符合限制2的设定，会销毁并新建元素。

但是当我们使用`key`指明了节点前后对应关系后，`react`知道`key = 'ka'`的`p`元素在更新后还存在，所以`DOM`节点可以复用，只是需要交换一下顺序。

### diff算法实现
`diff`算法的入口函数是`reconcileChildFibers()`,该函数会根据`newChild`（`jsx`对象）类型调用不同的处理函数。

`react`根据同级的节点数量将`diff`分为两类：

1. `newChild`类型为`object`、`number`、`string`，代表同级只有一个节点
2. `newChild`类型为`Array`，同级有有多个节点

### 单节点diff
对于单个节点，以类型`object`为例，会进入`reconcileSingleElement()`。该函数会做如下事情：
1. 判断上次更新的`fiber`节点是否存在对应的`DOM`节点，如果没有直接新建一个`fiber`节点并返回；有则进入下一步。
2. 判断`DOM`节点是否可以复用，可以复用则直接复用；不可复用则标记`DOM`需要删除，然后生成一个新的`fiber`节点并返回。

如何判断`DOM`节点是否可以复用？

`react`会先判断`key`是否相同，如果`key`相同则判断`type`是否相同，只有都相同时一个`DOM`节点才能复用。

### 多节点diff
多节点`diff`可以归纳为三种情况：
1. 节点更新，节点的属性或者类型发生变化
2. 节点新增或减少
3. 节点位置发生变化

同级多节点`diff`，一定属于以上三种情况的一种或多种。

#### 多节点diff思路
`diff`最基本的思路就是判断当前节点的更新属于哪种情况，根据不同情况实现不同的逻辑。这里的情况有三种：新增、删除、更新。

然而，在日常开发中，相较于新增和删除，更新组件发生的频率更高，所以`diff`会优先判断当前节点是否属于更新。

**注意**：数组中一般会用双指针遍历来提高效率，但这里不行。虽然`jsx`对象`newChild`
是数组形式，但`current fiber`不是，同级的`fiber`节点是由`sibling`指针链接形成的单链表，不支持双指针遍历。

基于以上原因，`diff`算法的整体逻辑会经历两轮遍历：
- 第一轮遍历处理更新的节点
- 第二轮遍历处理不属于更新的节点

#### 第一轮遍历
第一轮遍历步骤如下：
1. `let i = 0`，遍历`newChildren`，将`newChildren[i]`与`oldFiber`作比较，判断`DOM`节点是否可以复用。
2. 如果可复用，`i++`，继续比较`newChildren[i]`与`ildFiber.sibling`，可以复用则继续遍历。
3. 如果不可复用，分为两种情况：
- `key`不同导致不可复用，立即跳出整个遍历，第一轮遍历结束
- `key`相同但`type`不同，将`oldFiber`标记为`DELETION`，并继续遍历
4. 如果`newChildren`遍历完或者`oldFiber`遍历完则跳出遍历，第一轮遍历结束

对于步骤3跳出的遍历，此时`newChildren`和`oldFiber`都是没有遍历完的。

对于步骤4跳出的遍历，`newChildren`和`oldFiber`有一个遍历完或者全遍历完了。

#### 第二轮遍历
对于第一轮遍历的结果，可能产生如下一种情况：
1. `newChildren`和`oldFiber`同时遍历完，这是最理想的情况，第一轮遍历组件更新直接完成，此时`diff`结束。
2. `newChildren`没遍历完，`oldFiber`遍历完了，此时能复用的`DOM`都复用了，还有新增节点没有插入，我们只需要遍历剩下的`newChildren`为生成的`workInprogress fiber`一次标记为`Placement`即可。
3. `newChildren`遍历完，`oldFiber`没遍历完，意味着本次更新有节点被删除，只需要遍历剩下的`oldFiber`，依次标记为`Deletion`。
4. `newChildren`和`oldFiber`都没有遍历完，这意味着有节点在更新中改变了位置，此时需要处理移动的节点。

如何处理移动的节点？

因为位置发生了改变，所以不能再用位置索引`i`对比前后的几点，需要使用`key`。为了快速找到`key`对应的`oldFiber`，我们将所有还未处理的`oldFiber`存入以`key`为**键**，以`oldFiber`为值的`Map`中。

标记节点是否移动

节点是否移动肯定是有参照物的，这个参照物是：最后一个可复用的节点在`oldFiber`中的位置索引（`lastPlacedIndex`）。

由于本次更新是按照`newChildren`的顺序排列。在遍历`newChildren`的过程中，每个**遍历到的可复用节点**一定是当前遍历到的**所有可复用节点**中最靠右的那个，即一定在`lastPlacedIndex`对应的**可复用节点**在本次更新中位置的后面。

那么我们只需要比较**遍历到的可复用节点**在上次更新时是否也在`lastPlacedIndex`对应的`oldFiber`后面，就能知道两次更新中这两个节点的相对位置有没有变化。

我们用变零`oldIndex`表示**遍历到的可复用节点**在`oldFiber`中的索引。如果`oldIndex < lastPlacedIndex`，代表本次更新该节点需要向右移动。

`lastPlacedIndex`初始为0，每遍历一个可复用的节点，如果`oldIndex >= lastPlacedIndex`，则`lastPlacedIndex = oldIndex`。

在交换位置时，为了性能优化，我们要尽量减少将节点从后面移动到前面的操作，而是将节点从前往后移。
`abcd -> acdb`，只需要将`b`挪到最后一位
`abcd -> dabc`，这里看起来只需要将`d`移到第一位，但实际上`react`会保持`d`不变，将`abc`分别移到`d`的后面。

## Hooks

### useState
以 `const [date, setDate] = useState(1)` 为例
#### setDate函数式更新
- `setState` 支持函数语法更新，如下：
```js
const [date, setDate] = useState(1)
setDate(date => date + 1)
```
- 如果 `setDate` 在形成闭包的作用域中使用，会沿着作用域读取闭包中的 `date`，在更新一次后，`useState` 中的 `date` 更新了，但闭包中的 `date` 还是初始值，这样就会造成 `setDate` 只能对 `date` 更新一次。
- 函数式更新有一个传参的过程，`useState` 会将最新状态的 `date` 作为参数传入，这样就避免了受闭包影响。
- `setData` 还可以传入其他更复杂的计算函数用于更新 `data`，但该函数必须要有返回值
#### setDate是异步的
- `setDate` 每次更新 `data` 后都会触发 `UI` 渲染（这是`useState`的机制），`UI` 渲染是异步的过程，因此 `setDate` 更新也被设计为异步的
- 如果 `setDate` 涉及到多次计算，同步代码中就只能得到首次计算后的结果
- 结合 `useEffect` 使用，在 `useEffect` 中执行 `setDate` 可以解决异步更新问题

### useEffect
```js
useEffect(didUpdate, deps)
```
1. `useEffect`用于执行包含副作用的函数。
2. 默认情况下，`effect`在每轮渲染结束后都会执行，`useEffect`第二个参数（可选）接受一个依赖数组，仅当依赖数组中的项改变时`useEffect`才执行。如果这个数组为空，则`effect`只在首次渲染的时候执行。
3. `useEffect`中可以返回一个清除函数来卸载已经创建的`effect`。为防止内存泄露，清除函数会在组件卸载前执行。如果组组件多次渲染，则在执行下一个`effect`前，上一个`effect`就被清除了。
4. `useEffect`集合了三个生命周期的作用：`componentDidMount`、`componentDidUpdate`和`componentWillUnmount` 。

### useLayoutEffect
`useLayoutEffect`与`useEffect`的功能是完全一样的，只是执行时机不一样：`useLayoutEffect`会在所有的`DOM`变更之后同步调用`effect`。

可以`useLayoutEffect`中读取`DOM`布局并同步触发渲染，在浏览器执行绘制之前，`useLayoutEffect`内部的更新计划将被同步更新。

执行时机对比：在`Fiber`架构中，`Renderer（渲染器）`负责将变化的组件渲染到页面上，`Renderer`工作的阶段称为`commit`阶段，`commit`阶段由分为三个阶段：
1. `before mutation`阶段——执行`DOM`操作之前
2. `mutation`阶段——执行`DOM`操作中
3. `layout`阶段——执行`DOM`操作之后

`useEffect`的执行时机是`before mutation`阶段；`useLayoutEffect`的执行时机是`layout`阶段。
### useMemo
```js
const memoizedValue = useMemo(() => computeValue(a, b), [a, b])
```
1. `useMemo`返回的是一个`memoized`值。
2. `useMemo`接受两个参数，第一个参数是有返回值的函数，第二个参数是依赖数组。
3. 仅当依赖数组中的项改变时才重新计算 `memoized`的值。
`useMemo`作为性能优化的手段，能够避免在每次渲染时都进行高开销的计算。
**注意**：传入`useMemo`的函数会在渲染期间执行，不要再这个函数内部执行副作用相关的操作，这些操作应该放在`useEffect`中执行。

### useCallback
```js
const memoziedCallback = useCallback(() => {
  doSomething(a, b)
}, [a, b])
```
1. `useCallback`返回值是一个`memozied`回调函数。
2. `useCallback`接受两个参数，第一个参数是函数，第二个参数是依赖数组。
3. 仅当依赖数组中的项改变时，`useCallback`返回的回调函数才会更新。
`useCallback`与`useMemo`类似，也是作为性能优化的手段，`useCallback(fn, deps)`相当于`useMemo(() => fn, deps)`。


### useContext
`createContext() + useContext`是`react`自身可以用来实现跨层级传输数据的方案。 

`useContext`接受一个`context`对象(`createContext()`的返回值)并返回该`context`的当前值。

当前的`context`值由上层组件中距离当前组件最近的`<MyContext.Provider>`的`value`值决定。

当上层最近的`MyContext.Provider`更新时，`useContext`会触发重新渲染，并使用最新的`<MyContext.Provider>`的`value`值。当前组件的祖先如果使用了`memo`，不会影响`useContext`的重新渲染。

下面是一个`createContext + useContext + useReducer`模拟用户登录的案例：
```js
// context.js

import React, { createContext } from 'react';

// 登录上下文环境
export const AuthContext = createContext()

// 初始状态（未登录）
export const authInitiaStarte = {
  isAuthenticated: false,
  user: null,
  token: null
}

// 构建状态树
export const authReducer = (state, action) => {
  switch (action.type) {
    case "LOGIN":
      localStorage.setItem('user', JSON.stringify(action.payload.user))
      localStorage.setItem('token', JSON.stringify(action.payload.token))
      return {
        ...state,
        isAuthenticated: true,
        user: action.payload.user,
        token: action.payload.token
      }
    case "LOGOUT":
      return {
        ...state,
        isAuthenticated: false,
        user: null
      }
    default:
      return state
  }
}
```

```jsx
// App.js

import { useEffect, useReducer } from 'react'
import './App.css'
import { AuthContext, authInitiaStarte, authReducer } from './contexts'
import { Header, AddSong } from './components'

function App() {
  // 创建 reducer 形式的 state，第一个参数是纯函数形式的状态树，第二个参数是初始值
  const [state, dispatch] = useReducer(authReducer, authInitiaStarte)
  useEffect(() => {
    setTimeout(() => {
      dispatch({
        type: "LOGIN",
        payload: {
          user: {
            name: 'yzx',
            age: 22
          },
          token: {t:'1111223124e'}
        }
      })
    }, 2000);
  }, [])

  return (
    // 用 AuthContext.Provider 容器将子组件包裹起来，通过value属性向下层组件传入 reducer 的 state 和 dispatch方法
    <AuthContext.Provider value={
      {
        state,
        dispatch
      }
    }>
      <Header></Header>
      {state.isAuthenticated && <AddSong></AddSong>}
    </AuthContext.Provider>
  )
}

export default App
```

```jsx
// Header.js

import React, { useContext } from 'react';
import { AuthContext } from '../../contexts'

export const Header = () => {
  // 从 AuthContext 上下文中取出其 value 中传递的 state 和 dispatch
  const { state, dispatch }  = useContext(AuthContext)
  return (
    <>
      Header
      {state.isAuthenticated ? (
        <div>登录了{state.user.name}:{state.token.t}
          <button onClick={() => { dispatch({ type: 'LOGOUT' })}}>退出登录</button>
        </div>
      ) : (
        <div>未登录</div>
      )}
    </>
  )
}
```

```jsx
// AddSong.js

import React, { useContext, useEffect } from 'react';
import { AuthContext } from '../../contexts'

export const AddSong = () => {
  // 从 AuthContext 上下文中取出其 value 中传递的 state 和 dispatch
  const {state, dispatch} = useContext(AuthContext)
  useEffect(() => {
    fetch('https://www.fastmock.site/mock/4f8c468ae7202f91850147535d932340/sbt/ali/login',
    {
      method: 'post',
      headers: {
        Authoeization: `${state.token.t}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        username: '1111111',
        password: '2222'
      })
    }
    )
  }, [])

  return (
    <>
      AddSong
    </>
  )
}
```

### useReducer
`useState`的替代方案。它接受一个状态树，并返回当前的`state`以及配套的`dispatch`方法。

当`state`逻辑复杂且包含多个子值时，使用`useReducer`，这样可以向子组件传递`dispatch`而不是回调函数，子组件中可以使用`dispatch`返回相应的`action`，这样就能匹配状态树中相应的项。

下面是使用`useReducer`实现计数器组件的例子：
```jsx
const reducer = (state, action) => {
  switch (action.type) {
    case 'ADD_NUM': 
      return { count: state.count + 1 }
    case 'SUB_NUM':
      return { count: state.count - 1 }
    default: 
      throw new Error()
  }
}

const App = () => {
  const [ state, dispatch ] = useReducer(reducer, { count: 0 })
  return (
    <>
      <p> count: {state.count} </p>
      <button onClick={() => dispatch({type: 'ADD_NUM'})} >+</button>
      <button onClick={() => dispatch({type: 'SUB_NUM'})} >-</button>
    </>
  )
}
```
**注意**：`dispatch`函数的标识是稳定的，并不会在组件重新渲染时改变。在`useEffect`或`useCallback`的依赖项中可以省略`dispatch`。

#### 惰性初始化
`useReducer`第三个参数可以设置为`init`初始化函数，这样初始`state`将被设置为`init`函数的返回值。

这样做可以将用于计算的`state`的逻辑提取到`reducere`外部，这也为将来对重置`state`的`action`处理提供了便利。

还是以计数器组件为例：
```jsx
function init(initialCount) {
  return { count:initalCount }
}

const reducer = (state, action) => {
  switch (action.type) {
    case 'ADD_NUM': 
      return { count: state.count + 1 }
    case 'SUB_NUM':
      return { count: state.count - 1 }
    // 计数器状态重置的case
    case 'RESET': 
      return init(action.payload)
    default: 
      throw new Error()
  }
  
const App = ({initialCount}) => {
  const [state, dispatch] = useReducer(reducer, initialCount, init)
  return (
    <>
      <p>Count: {state.count}</p>
      // 状态重置按钮以及状态重置事件
      <button onClick=(() => dispatch({type: 'reset', payload: initialCount}))> reset </button>
      <button onClick={() => dispatch({type: 'ADD_NUM'})} > + </button>
      <button onClick={() => dispatch({type: 'SUB_NUM'})} > - </button>     
    </>
  )
}
```
### useRef
```js
const myRef = useRef(initialValue)
```
`useRef`返回一个可变的`ref`对象，这个对象的`current`属性被初始化为传入的参数。返回的`ref`对象在组件的整个生命周期内持续存在。

`useRef`一个常见的使用场景就是*命令式地访问子组件*，下面是一个通过`useRef`和点击事件聚焦`<input>`元素的案例：

```jsx
const App = () => {
  const inputRef = useRef(null)
  const buttonClick = () => {
    inputRef.current.focus()
  }
  
  return (
    <>
      <input ref={inputRef} type='text'></input>
      <button onClick={buttonClick}> Focus the input </button>
    </>
  )
}
```

`useRef()`和一个自建的普通对象（例如`{current:A}`）只有一个区别：`useRef()`在每次渲染时返回同一个`ref`对象。

**注意**：`ref`对象的内容发生变化时，`useRef`并不会通知你。`current`值发生改变不会引起组件重新渲染。

### useImperativeHandle
```js
useImperativehandle(ref, createHandle, [deps])
```
`useImperativehandle`可以将子组件的`ref`暴露给父组件。

`useImperativeHandle`应当与`forwardRef`一起使用：

```jsx
const MyInput = (props, ref) => {
  const inputRef = useRef()
  useImperativeHandle(ref, () => (
  	{
  	  focus: () => {
  	    sonRef.current.focus()
  	  }
  	}
  ))
  
  return <input ref={inputRef} />
}
MyInput = forwordRef(MyInput)

const App = () => {
  const inputFocus = () => {
    inputRef.current.focus
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={inputFocus}> Focus </button>
    </>
  )
}
```

## react事件机制-合成事件

![](C:\Users\21133\Pictures\js\reactshijian.png)

`react`拥有自己的一套事件绑定机制，这种机制就是合成事件。这么做是因为`react`想实现一个全浏览器的框架，为了实现这种目标就需要提供全浏览器一致性的事件系统，以此来抹平不同浏览器的差异。

### 合成事件
在`react`中，我们绑定的事件`onClick`等并不是浏览器原生事件而是由原生事件合成的事件。

> 合成事件是由`SyntheticEvent`包装器包装而成。`SyntheticEvent`实例会被传递给事件处理函数，它是浏览器原生事件的跨浏览器包装器。除了兼容所有的浏览器之外，它还拥有和浏览器原生事件的接口，包括`stopPropagation()`和`preventDefault()`。

### react如何绑定事件
#### 三个重要对象
`react`提供的合成事件与原生的浏览器事件是对应的，这种对应关系存放在`react`插件**`EventPlugin`**中。事件插件可以认为是`react`将不同的合成事件处理函数封装成了一个模块，每个模块只处理自己对应的合成事件，这样不同的事件种类就可以在代码上解耦。例如`onChange`事件就有一个单独的`legacyChangeEventPlugin`插件来处理。

要做到事件绑定，就需要知道合成事件与原生事件的关系，`react`在一开始就会将事件插件全部加载进来，这部分逻辑在**`ReactDOMClientlnjection`**中：
```js
injectEventPluginsByName({
    SimpleEventPlugin: LegacySimpleEventPlugin,
    EnterLeaveEventPlugin: LegacyEnterLeaveEventPlugin,
    ChangeEventPlugin: LegacyChangeEventPlugin,
    SelectEventPlugin: LegacySelectEventPlugin,
    BeforeInputEventPlugin: LegacyBeforeInputEventPlugin
})
```
注册完插件后，**`EventPluginRegistry`**这个模块就初始化好了一些全局对象，以下几个对象比较重要：
1. `registrationNameModule`：它包含了`react`事件到它对应的`plugin`的映射和`react`支持的所有事件类型，这个对象的最大作用就是判断一个组件的`prop`是否是事件类型，这在处理原生组件的`props`时会用到，一个`prop`只有在这个对象中才会被当做事件处理。
```js
{
    onBlur: SimpleEventPlugin,
    onClick: SimpleEventPlugin,
    onClickCapture: SimpleEventPlugin,
    onChange: ChangeEventPlugin,
    onChangeCapture: ChangeEventPlugin,
    onMouseEnter: EnterLeaveEventPlugin,
    onMouseLeave: EnterLeaveEventPlugin,
    ...
}
```
2. **`registrationNameDependencies`**：这个对象就是***合成事件到原生事件的映射***。对于`onClick`和`onClickCapture`事件，只依赖原生的`click`事件，但是`onMouseLeave`（鼠标离开）却依赖`mouseout`和`mouseover`两个事件，说明`onMouseLeave`事件是`react`用`mouseout`和`mouseover`模拟合成的。正是因为这种行为，使得`react`能够合成一些浏览器不支持的事件供我们使用。
3. **`plugin`**，这个对象是上面注册的所有插件列表。
```js
plugins = [LegacySimpleEventPlugin, LegacyEnterLeaveEventPlugin, ...]
```

***普通的`EventPlugin`形式如下***，一个`plugin`就是一个对象，这个对象包含了两个属性：

```js
// event plugin
{
  eventTypes, // 一个数组，包含了所有合成事件相关的信息，包括其对应的原生事件关系
  extractEvents: // 一个函数，当原生事件触发时执行这个函数
}
```

#### 绑定事件流程
1. `react`指定`diff`操作，标记出哪些`DOM`类型的节点需要添加或者更新。
2. 当检测到需要创建或者更新节点时，使用`registrationNameModule`查看一个`prop`是不是一个事件类型，如果是则执行下一步。
3. 通过`registrationNameDependenCies`检查这个`react`事件依赖了哪些原生事件。
4. 检查这些原生事件有没有被注册过，如果有则忽略。
5. 如果这个原生事件没有被注册过，则将这个事件注册到`document`上，回调为`react`提供的`dispatchEvent`函数。

根据上述流程，可以得出以下结论：
1. `react`将所有事件都注册到`document`上。
2. 所有原生事件的`listener`（监听者）都是`dispatchEvent`函数。
3. 同一类型的事件`react`只会绑定一次原生事件。无论我们写了多少个`onClick`，最终反应在`DOM`事件上只会有一个`listener`。
4. `react`并没有将我们业务逻辑里的`listener`绑定在原生事件上，也没有去维护一个队列来存放我们的`listener`，而是去中心化存储在各自的`fiber node`上。

因此，我们的业务逻辑的`listener`和实际`DOM`事件没有关系，`react`只是会确保这个原生事件能够被它捕捉到，后续由`react`来派发我们的事件回调。当我们的页面发生较大的切换时，`react`可以什么都不做，从而免去了移除事件或者同步事件队列的操作，所以其执行效率会大大提高。这相当于全局给我们做了一次事件委托，即便是渲染大列表，也不用开发者关心事件绑定问题。

### react触发事件
在`react`中，所有类型的事件都会绑定为`dispatchEvent`函数，所以能在全局处理一些通用行为，代码如下：
```js
export function dispatchEventForLegacyPluginEventSystem(
  topLevelType: DOMTopLevelEventType,
  eventSystemFlags: EventSystemFlags,
  nativeEvent: AnyNativeEvent,
  targetInst: null | Fiber,
): void {
  const bookKeeping = getTopLevelCallbackBookKeeping(
    topLevelType,
    nativeEvent,
    targetInst,
    eventSystemFlags
  );

  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    batchedEventUpdates(handleTopLevel, bookKeeping);
  } finally {
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}
```
`bookKeeping`为事件执行组件的层级做存储，如果事件执行过程中组件结构发生改变，并不会影响事件的触发流程。

整个触发事件流程如下：
1. 任意一个事件触发都会执行`dispatchEvent`函数。
2. `dispatchEvent`执行`batchedEventUpdates(handleTopLevel)`，`batchedEventUpdates`会打开批量渲染开关并调用`handleTopLevel`。
3. `handleTopLevel`会依次执行`plugin`里所有的事件插件。
4. 如果一个插件检测到自己需要处理的事件类型时，则处理该事件。

对于大部分事件来说处理逻辑如下，也就是`LegacySimpleEventPlugin`插件做的工作：
1. 通过原生事件类型决定使用哪个合成事件类型，合成事件类型就是原生`event`封装对象，例如`SyntheticMouseEvent`。
2. 如果对象池里有这个类型的实例，则取出这个实例，覆盖其属性，作为本次派发的事件对象（事件对象复用），若没有则新建一个实例。
3. 从点击的原生事件中找到对应的`DOM`节点，从`DOM`节点中找到一个最近的`react`实例，从而找到一天由这个实例父节点不断向上组成的链，这个链就是我们要触发合成事件的链（链中只包含原生组件）。
4. 反向触发这条链，父节点向子节点传递，模拟事件捕获阶段触发所有`props`中含有`onClickCapture`的实例。
5. 正向触发这条链，字节点向父节点传递，模拟事件冒泡阶段，触发`props`中含有`onClick`的实例。

这几个阶段中总结出以下结论：
1. `react`的合成事件只能在时间周期内使用，因为对象很可能被其他阶段复用，如果想要持久化就需要手动调用`event.persisit()`，告诉`react`这个对象需要持久化（`recat17`中弃用）。
2. `react`中的冒泡和捕获是模拟的，并不是真正的事件冒泡和捕获。
3. `react`会在一个原生事件里触发所有相关节点的`onClick`事件，在执行这些`onClick`之前`react`会打开批量渲染开关，这个开关会将所有的`setState`变成异步函数。
4. 事件只对原生组件生效，自定义组件不会触发`onClick`。

### react事件总结
1. `react16`将原生事件都绑定在`document`上，`react`事件实际上都是在`document`上触发的。
2. 我们收到的`event`对象是`react`合成事件中的，在事件之外不可使用，如下代码就是错误用法：
```js
function onClick(event) {
  setTimeout(() => {
    console.log(event.target.value)
  }, 100)
}
```
3. `react`会在派发事件的时候打开批量更新，此时所有的1`setState`都会变成异步。
```js
function onClick() {
  setState({a : 1}) // 1
  setState({a : 2}) // 2
  setTimeout(() => {  
    setState({a : 3}) // 3
    setState({a : 4}) // 4
  }, 0)
}
```
上述代码中，1、2在事件内部，所以是异步的，只会触发一次`render`操作，而3、4在事件外，是同步的，它们会分别触发一次`render`。
4. `react`的`onClick、onClickCapture`，实际上都发生在原生事件的冒泡阶段，所以`react16`中实际上不支持绑定捕获事件。
5. 由于多个事件都注册到顶层`document`上，所以多个`ReactDOM.render`会存在冲突。如果我们在子树中调用了`e.stopPropagation`，事件依然会冒泡，所以多版本的`react`在事件上存在冲突。

![](C:\Users\21133\Pictures\js\reactshijianv16.png)

### react17事件改动
`react17`没有新特性更新，也没有重大重构，而是积攒了大量`bugFix`，修复了之前存在的诸多缺陷，其中最大的变化就是对事件系统的改造。

1. 事件不在绑定在`document`上，而是绑定在`container`上，`ReactDOM.render(app, container)`。这样能够解决多版本共存问题。
2. 支持原生捕获事件，对齐了浏览器原生标准。同时`onScroll`不再进行事件冒泡；`onFocus`和`onBlur`使用原生`focusin`、`focusout`合成。
3. 取消事件复用，官方解释是事件对象的复用在现代浏览器上性能的提升已经不明显，反而容易让人犯错，所以干脆就放弃了这个优化。
## 受控组件非受控组件
- 受控与非受控指的是对某个组件状态的掌控，组件状态的值是否只能由代码设置而不受用户掌控。
- 如果一个 `input` 表单元素的值是由 `React` 控制，就其称为受控组件。当用户将数据输入到受控组件时，会触发修改状态的事件处理器，这时由代码来决定此输入是否有效（如果有效就使用更新后的值重新渲染）。如果不重新渲染，则表单元素将保持不变。
- 一个非受控组件，就像是运行在 `React` 体系之外的表单元素。当用户将数据输入到表单字段（例如 `input、dropdown` 等）时，`React` 不需要做任何事情就可以映射更新后的信息。但这也意味着无法强制给这个表单字段设置一个特定值。
### 受控组件
- 受控组件主要是表单元素，因为表单元素工作方式与其他的 `DOM` 元素有些不一样，表单元素通常会维护一些内部的状态。例如 `input` 就有自己的 `value` 属性用来接收用户输入的值
- 在 `HTML` 中，表单元素（`<input>、<textarea>、<select>` 等）通常维护自己的 `state`，比如`input` 维护自己的 `value` 属性，并根据用户输入进行更新。
- 在 `react` 中，数据是单向绑定的，可变状态通常保存在组件的 `useState` 中（`class` 组件在 `state` 属性）中，并且只能通过 `setState()` 来更新
- 结合表单元素的自有 `state` 和 `react` 的 `useState` ，使 `react` 的 `state` 成为表单元素唯一的数据源，渲染组件的同时还控制了用户对表单的输入，被这种方式控制取值的表单元素就叫做**受控组件**
- 以 `input` 为例，可以 `const [data, setData] = useState('abc')` 来创建一个 `data`，然后将 `input` 的 `value` 的属性设置为 `data`，最后用一个 `onChange` 事件来监听输入的内容并用 `setData` 更新 `data`，这样后续 `input.value` 的值只通过 `setData` 来更新
```js
import React, { useState } = 'react'
const TestComponents = () -> {
  const [data, setData] = useState('abc')
  return (
    <>
	  <input name="username" 
	    value={data} 
	    onChange(e => setData(e.target.value))
	  >
    </>
  )
}
```

### 非受控组件
- 一般情况下推荐使用**受控组件**来处理表单数据，但可以用**非受控组件**代替这种方案，这时表单数据交给 `DOM` 节点处理而不是由 `useState()` 处理
- 在 `react` 中可以通过 `ref` 来暴露子组件的 `DOM` 属性
```js
import React, { createRef } = 'react'
const TestComponents = () -> {
  const dataRef = createRef()
  const handleSubmit = e => {
    e.preventDefault()
  }
  return (
    <>
      <form onSubmit={handleSubmit}>
        <input type="text" 
         ref={dataRef} 
         onChange(e => setData(e.target.value))
        >
      </form>
    </>
  )
}
```
## Suspense
`suspense`使组件可以“等待”某些操作结束后，再进行渲染。目前`suspense`仅能和`lazy`结合使用达到动态加载组件的效果。这二者是捆绑关系，必须结合使用。
- `es6 module`的`import`是静态编译时输出接口，在代码执行之前，所有的组件在代码执行之前就已经加载好了，这无疑是一种浪费，因为在`react`很多组件并不是立刻就要用到。
- `react` 中提供了 `lazy` 函数用来实现动态加载，这有助于缩减`bundle`的体积，并延迟加载在初次渲染时没用到的组件。
- 在`react`中路由也是组件，因此这种方案常常用来动态加载路由。

想要渲染`lazy`的组件，就需要使用`Suspense`组件将其包裹，`Suspense`组件中需要指定`fallback`属性，该属性是个占位符，指定了`lazy`的组件渲染之前展示的东西。

下面是一个动态加载路由的案例：
```js
// App.js
import { lazy } from react
import Route1 from './Route1'
const Route2 = lazy(() => import('./Route2'))
```
```js
// main.js
import { Suspense } from 'react'
import ReactDOM from 'react-dom'
import './index.css'
import App from './App'

ReactDOM.render(
  <Suspense fallback={<p>loading...</p>}>
    <App />
  </Suspense>,
  document.getElementById('root')
)
```

# typescript
- 微软开发、自由开源，是`javaScript`的超集
- 与`js`的区别：

| typescript                                     | javascript                                 |
| :--------------------------------------------- | :----------------------------------------- |
| 用于解决大型项目的代码复杂性                   | 一种脚本语言，用于创建动态网页             |
| 可以在编译期间发现并纠正错误                   | 作为一种解释型语言，只能在运行时发现错误   |
| 强类型，支持静态和动态类型                     | 弱类型，没有静态类型选项                   |
| 最终被编译成 JavaScript 代码，使浏览器可以理解 | 可以直接在浏览器中使用                     |
| 支持模块、泛型和接口                           | 不支持模块，泛型或接口                     |
| 支持 ES3，ES4，ES5 和 ES6 等                   | 不支持编译其他 ES3，ES4，ES5 或 ES6 功能   |
| 社区的支持仍在增长，而且还不是很大             | 大量的社区支持以及大量文档和解决问题的支持 |

## node中使用ts
1. 安装`npm`包：`tyarn add typescript tsc-watch --save-dev`
2. `package`配置`script`
```js
"start:dev": "tsc-watch --onSuccess \"node dist/main.js\""
```
3. 配置`ts.config.json`文件：
```json
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "target": "es2017",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```
### 文件解释
1. `main.js.map`：别名 `sourcemap`，资源映射文件，保持着对 `mian.ts`文件的映射关系，用于代码调试。`main.ts => main.js`转化会做代码的压缩和混淆，在调试时，会报源文件的错误。生成该文件需要在 `ts.config.json` 配置  `"sourceMap": true`。


## 运行命令
- `tsc 1.ts` 编译 `1.ts` 文件，并生成同名的 `1.js` 文件

# 工程化
## 模块化
- `AMD`：速度快 | 会浪费资源 | 预先加载所有的依赖，直到使用的时候才执行，适合浏览器端。
- `CMD`：只有真正需要才加载依赖 | 性能较差 | 直到使用的时候才定义依赖，适合服务端。
- `Commonjs`：主要应用于`NodeJs`中。
- `es6 module`：在`es6`语言标准的层面上实现的模块化功能。
**RequireJS 遵循 AMD（异步模块定义）规范，Sea.js 遵循 CMD （通用模块定义）规范，node.js遵循CommonJS规范。**

### AMD
`Asynchronous Modules Definition` 异步模块定义，提供定义模块及异步加载该模块依赖的机制。

`AMD`规范采用异步方式加载模块，模块的加载不影响它后面语句的运行，所有依赖这个模块的语句都定义在一个回调函数中，等到加载完成后，该回调函数才会运行。`require.js`是`AMD`规范的主要应用者，主要有以下`api`：

1. `require.config()`：指定引用模块路径、引用名等
2. `define()`：定义模块
3. `require()`：引用模块

*引用模块的时候，将模块名放在一个数组中作为`require()`的第一个参数。如果定义的模块本身也依赖其他模块，就需要将模块名放在数组中作为`define()`的第一个参数。*

`AMD`使用`define()`定义模块。
```js
define(['./a', './b'], function(a, b) { //运行至此，a.js和b.js已经下载完成 a模块和b模块已经执行完，直接可用；
    a.doing();
    // 此处省略500行代码
    b.doing();
})
```

### CMD
`Common Module Definition` 通用模块定义，提供模块定义及按需执行模块。

`CMD`与`AMD`很类似，不同点在于：*`AMD`推崇依赖前置，提前执行；`CMD`推崇依赖就近、延迟执行*，此规范是在`sea.js`推广过程中产生的。

`CMD` 代码模式：
```js
define(function(require, exports, module) {
     var a = require("./a"); //等待a.js下载、执行完
     a.doing();
     // 此处省略500行代码
     var b = require("./b"); //依赖就近书写
     b.doing();
});
```

### CommonJs
`commonjs`是应用于`node.js`中的模块化方案。在`node.js`中，每个文件都是一个模块，拥有自己独立的作用域、变量、方法等等，这些对其他模块都不可见。

*`CommonJs`规范规定，每个模块内部，`module`变量代表当前模块，这个变量是一个对象，它的`exports`属性（即`module.exports`）是对外的接口。加载某个模块，其实就是加载该模块的`module.exports`属性。`require()`方法用于加载模块。*

`commonjs`规范有两种输出方式，注意区分：

1. `module.exports`属性：这个属性表示当前模块对外输出的接口，其他文件加载该模块其实就是读取`exports`变量。
2. `exports`变量：`node`为每一个模块提供了一个`exports`变量指向`module.exports`，这相当于`var exports = modules.exports`。对外输出时，可以在这个变量上添加方法，例如`export.add = function(){}`。***注意不要把`exports`直接指向一个值（例如`exports = obj`），这样就切断了`exports`对`module.exports`引用关系。***

> `commonjs`用同步的方式加载模块。在服务端，模块文件都存储在本地磁盘，读取非常快，这么做没什么问题，但在浏览器中，限于网络原因，更合理的方案是使用异步加载方案。

### es6 Module
`es6 module`模块功能主要由两个命令构成——`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于引入其他模块提供的功能。

**定义模块**
```js
// util.js
export const add = function(x, y) {
  return x + y
}

export const obj = {a:1, b:2}
```
**引入模块**
```js
import { add, obj } from './util.js'
```
在使用`import`命令的时候，用户需要知道需要加载的变量名或者函数名。`es6 module`还提供了`export default`命令为模块指定默认输出，这样对应的`import`语句就不需要使用大括号。
```js
// util.js
const fn = function () {}
export default fn
```

```js
import fn from './util.js'
```

> `es6`的模块不是对象，`import`命令会被`js`引擎静态分析，在编译阶段就引入代码模块，而不是在代码运行时才加载，因此`es6 module`无法实现条件加载，但这使得静态分析成为可能。

### commonjs与es6 module的区别
1. ***模块输出的值的类型不同，`commonjs`模块输出的是一个值的拷贝，`es6`模块输出的是值的引用。***`commonjs`模块输出的是值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。`es6 module`模块输出的是对值的引用，会受到模块内部变化的影响。这是因为`es6 module`运行机制和`commonjs`不一样。`js`引擎对脚本进行静态分析的时候如果遇到`import`加载命令就会生成一个只读引用，等到脚本真正执行时再根据这个引用到被加载的那个模块中取值。因此，`es6 module`模块时动态引用，不会进行值的缓存，模块里面的变量绑定其所在的模块。
2. ***加载时机不同，`commonjs`模块是运行时加载，`es6 module`是编译时输出接口***。`commonjs`模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上读取方法，这种加载称为**运行时加载**。`es6`模块不是对象，而是通过`export`命令显示指定输出的代码，`import`时采用静态命令的形式，即在`import`时可以指定加载某个输出值，而不是加载整个模块，这种加载称为**编译时加载**。`conmmonjs`加载的是一个对象（即`module.exports`），该对象只有在脚本运行时才会生成，而`es6`模块不是对象，它的对外接口是一种静态定义，在代码静态解析阶段就会生成。
3. ***支持的环境不同***。***在浏览器环境中***，`commonjs`需要通过支持它的`webpack`等打包工具转化成能在浏览器使用的代码，而`es6 module`只需要在`script`标签中添加`type = "module"`属性即可使用。***在`node`环境中***，`commonjs`是原生支持的，而`es6 module`语法需要通过`babel`转义工具才能实现，但其核心机制还是`commonjs`规范，只是语法层面上的实现。
4. ***语法以及特点不同***。`es6 module`中的`import`命令只能在模块顶层使用，不能在函数、判断条件语句等代码块中使用，而`commonjs`语句可以。`import`时不能对模块重新赋值/定义，而`commonjs`的`require()`可以。`es6`模块可以在`import`引用语句前使用模块，`commonjS`则需要先引用后使用。这些特性差异的本质原因还是1、2点。

## AST（抽象语法树）

### 何为AST

抽象语法树全称`Abstract Syntax Tree`，***它是源码语法结构的抽象表示***，以树的形式表现编程语言的语法结构，树中的每个节点代表源码的一个项。

为什么需要将`js`代码先转化为抽象语法树？
> 在计算机中，树结构有很多优异性质，它能够有效地解决储存的问题和计算时程序调用的问题。不仅仅有抽象语法树，`react`中有虚拟`DOM`树，页面中有`DOM`树和`CSSOM`树，很多地方都会将树结构作为语法结构的抽象表示。*
>
> 生成`AST`之后，编辑器或解释器都依靠`AST`工作。`babel`的工作原理就是将`es6`的`AST`转化成`es5`的`AST`，最后将`es5`的`AST`转化成具体的`es5`代码。

树的优点？
1. 树的大小是确定的，只需要`O(|V|)`的空间
2. 树是连通的，只需要进行一次搜索就可以完成遍历
3. 当树的根确定了，任意两点间的关系也唯一确定了，也可以看做有向图
4. 树的连通子图也是树
5. 当树比较均匀时，从根到叶的步数`~O(log|V)`
6. 树上两两节点之间存在唯一的简单路径
### 得到AST树
`javascript`中要得、到抽象语法树需要借助编译器或者转义工具，这里使用`babel`。需要安装`@babel/parser`。

一段简单代码：
```
const parser = require('@babel/parser')
const code = `
  let a = 1
  let b = {n : 2}
`
const ast = parser.parse(code) // 转化为抽象语法树

console.log(ast)
```
结果如下：

<img src="C:\Users\21133\Pictures\js\ast.png" style="zoom:75%;" />
整个`Node`节点表示`code`对应的`AST`的根节点，其中的`program`节点记录了`code`这段程序的信息，也就是上述代码的信息。`program`中有个`body`节点，它是个数组，`code`程序中变量信息就保存在`body`属性中。`body`内还有分支记录更详细的信息，但不管是哪一层的分支，都有一个`type`属性记录着分支的类型。

下面通过一段代实现解析`ast`的功能：
```js
const parser = require('@babel/parser')

const code = `
  let a = {n : 1}
  let b = 2
  let c = a
`

// 使用map来保存获取的标识符和值的映射
const scope = new Map()

function evaluate(node) {
  // 声明一个对象，里面每一项都对应着一种节点的递归处理方法
  const astInterpreters = {
    Program: function (node) {
      node.body.forEach(item => {
        evaluate(item)
      })
    },

    VariableDeclaration: function (node) {
      node.declarations.forEach(item => {
        evaluate(item)
      })
    },

    VariableDeclarator: function (node) {
      const declareName = evaluate(node.id) // 从变量名的节点获取变量名
      if (scope.get(declareName)) {
        throw Error('该变量已被声明!!!')
      } else {
        const valueNode = node.init // 从变量值的节点获取变量值
        let value
        if (valueNode.type === 'Identifier') {
          // 处理引用式赋值，例如 c = a，直接取出a即可
          value = scope.get(valueNode.name)
        } else {
          // 处理字面量赋值的节点，这些节点还有子节点需要递归处理
          value = evaluate(valueNode) 
        }
        // 存入标识符与值之间的映射
        scope.set(declareName, value)
      }
    },

	// 返回标识符（变量名）
    Identifier: function (node) {
      return node.name
    },

	// 返回object类型的值
    ObjectExpression: function (node) {
      const obj = {}
      node.properties.forEach(item => {
        const key = evaluate(item.key)
        const value = evaluate(item.value)
        obj[key] = value
      })
      console.log(obj, '000000')
      return obj
    },

	// 返回number类型的值
    NumericLiteral: function (node) {
      return node.value
    }
  }

  try {
    // 递归解析不同类型分支
    return astInterpreters[node.type](node)
  } catch (error) {
    console.error('不支持节点类型' + node.type, error)
  }
}

function myEval(code) {
  const ast = parser.parse(code)
  evaluate(ast.program)
}

myEval(code)
```
上述代码只简单地处理了`number`和`object`以及引用式赋值的变量，其他情况有需要可以加。

## babel

### babel重要npm包
-  `@babel/cli`：提供 cli 命令行工具，用来通过命令行编译文件，适合安装到本地项目中，安装后`node_modules/.bin`目录下会多一系列文件（`babel`，`babel.cmd`，`bebel.post` 等）
-  `@babel/core`：babel核心转换库，处理核心的转换
-  `@babel/preset-env`：babel配置中最常用的预处理，根据环境打包代码，可以配置 `env`，指定编译目标版本、支持的浏览器
-  `@babel/plugin-propasal-decorators `：插件支持类的装饰器语法, 包括类装饰器, 属性装饰器, 方法装饰器
-  `@babel/register`：实时编译 `es6 --> es5`，可以实现支持 `import` 引入方案，这样就不用`@babel/cli`手动转义了
-  `babel-loader`：配合 `webpack `使用，作为 `webpack `的 `loader`
### babel配置支持import

- 核心是配置`@babel/register`
- 需要安装`@babel/core`、`@babel/register`、`@babel/preset-env`

```js
/**
*@app.js运行文件
*@main.js——入口文件
*/
// main.js
require('@babel/register')
require('./app.js')
```
``` json
// .babelrc
// 这里的配置将js代码按照指定的目标版本编译
{
  "presets": [
    ["@babel/preset-env", {
      "targets": {
        "node": "current"  // 将代码转义成node当前版本
      }
    }]
  ]
}
```
## webpack
- `webpack` 是现代最强大的工作流套件，未来一段时间，`webpack` 仍然是主流，因为 `webpack` 拥有健硕而完善的社区和插件。
- `webpack` 是一个现代 `JavaScript` 应用程序的静态模块打包器(`module bundler`)。当 `webpack` 处理应用程序时，它会递归地构建一个依赖关系图(`dependency graph`)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 `bundle（捆绑）`。
- `webpack` 是高度可配置的
- 打包是为了让代码能在相应的环境（一般是浏览器环境）运行
### 核心概念
- 入口（`entry`）、输出（`output`）、`loader`、插件（`plugin`）
#### 入口（`entry`）
- 入口起点（`entry point`）决定从哪个文件（模块）开始构建内部依赖图。进入入口起点后，`webpack` 会找出有哪些模块和库是入口起点（直接和间接）依赖的。
- `webpack.config.js` 配置文件中可以配置 `entry` 属性，用来指定一个或多个入口起点，默认值为 `./src`
```js
// 直接指定入口文件
module.exports = {
  entry: './index.tsx'
}

// 入口文件取别名 app，指定为 './index.tsx'
module.exports = {
  entry: {
	app: ["./index.tsx"]
  }
}
```
#### 出口（`output`）
- `output` 属性规定 `webpack` 在哪里输出它所创建的 `bundles`，以及如何命名这些文件，默认值为 `./dist`。
```js
const path = require('path')

module.exports = {
  entry: { 
  // 入口文件，取别名 app 
    app: ["./index.tsx"]
  },
  output: { 
  // 出口配置，打包后文件前缀为 app + 随机哈希值，后缀为 .js
    filename: "[name].[chunkhash].js"
  }
}
```
#### loader
`loader`用于对模块的源代码进行转换。`loader`可以在`import`或者“加载”模块时预处理文件。`loader`可以将不同的语言转化为`javascript`，或者将内联图像转化为`data URL`。`loader`甚至允许在`js`模块中直接`import` `CSS`文件 
- `webpack` 本身只理解 `js`，`loader` 可以将所有类型的文件转换为 `webpack`能够处理的有效模块，然后 `webpack` 就能打包处理非 `js` 文件。
- `loader` 有两个目标：
	- `test` 属性：标识出应该被对应的 `loader` 进行转换的文件
	- `use` 属性：规定转换时使用哪个 `loader`
- `loader` 要定义在 `module.rules` 中，而不是 `rules`

安装`loader`：
```js
npm i --save-dev css-loader
npm i --save-dev ts-loader
```

使用`loader`：
```js
const path = require('path')

module.exports = {
  entry: { 
  // 入口文件，取别名 app 
    app: ["./index.tsx"]
  },
  output: { 
  // 出口配置，打包后文件前缀为 app + 随机哈希值，后缀为 .js
    filename: "[name].[chunkhash].js"
  },
module: {
    rules: [
      {
        test: /\.tsx?$/, // 正则匹配需要打包的文件
        exclude: /node_modules/, // 正则匹配需要排除的文件，不打包
        loader: "babel-loader" // 打包前先交给 babel 转义处理
      }
    ]
  },
}
```
#### 插件（plugin）
- `loader` 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。
- 使用插件只需要 `require()` 引入，然后添加到 `plugins` 数组中
- 多数插件可以通过选项（`option`）自定义。
- 在一个配置文件中需要多次使用同一个插件时，就要用 `new` 创建该插件的实例。
```js
const HtmlWebpackPlugin = require('html-webpack-plugin')
const path = require('path')

module.exports = {
  context: path.resolve(__dirname, 'src'), // 打包上下文

  resolve: {
    extensions: ['.ts', '.tsx', '.js'] // 指定自动解析的文件类型
  },

  entry: { // 入口文件，取别名 app 
    app: ["./index.tsx"]
  },

  module: {
    rules: [
      {
        test: /\.tsx?$/, // 正则匹配需要打包的文件
        exclude: /node_modules/, // 排除的文件，不打包
        loader: "babel-loader" // 打包前先交给 babel 转义处理
      }
    ]
  },

  output: { // 出口文件，打包后的文件后缀为 .js
    filename: "[name].[chunkhash].js"
  },

  plugins: [
    new HtmlWebpackPlugin({
      filename: "index.html",
      template: "index.html",
      scriptLoading: "blocaking" // 脚本阻塞式加载
    })
  ]
}
```
#### mode（模式）
*此参数可以启用`webpack`在响应环境下的优化，默认值为`production`。*

```js
module.exports = {
  mode: 'development'
}
```
`mode`的值有三个选项：
1. `development`—— 会将`DefinePlugin`中`process.env.NODE_ENV`的值设置为`development`。为模块和`chunk`启用有效的名称。
2. `production`—— 会将`DefinePlugin`中`process.env.NODE_ENV`的值设置为`production`。为模块和`chunk`启用确定性的混淆名称。
3. `none`—— 不使用任何默认优化选项。

### webpack工作流程
- `webpack` 启动，在根目录下寻找 `webpack.config.js` 默认配置文件，确定打包的上下文环境（`context`），从 `entry` 入口开始，根据文件后缀确认是否属于 `resolve` 范围。`module` 中根据 `rules` 匹配其中的一个 `test` 启用相应的 `loader` 做相应的处理，处理完后输出给 `output`。
- `webpack` 的下一级是 `loader`，`loader` 的下一级是各种转义工具或插件。
- 对于上述案例而言，流程是：`entry --> index.tsx --> resolve --> module(test) --> babel-loader --> .babelrc`
### 常用loader
- `file-loader`：把文件输出到一个文件夹中，在代码中通过相对`url`去引用输出文件。
- `image-loader`：加载并压缩图片文件。
- `babel-loader`：对文件进行转译（`es6 -> es5`），`babel-loader`很慢，应转义尽可能少的文件，可以在`exclude`中正则匹配`node_modules`目录排除掉它。启用`cacheDirectory`选项可以将`loader`的执行结果缓存起来，之后的`webpack`构建都会尝试读取缓存，这样可以大幅提高`babel-loader`的速度。
- `css-loader`： 加载`css`，支持`css`模块化、压缩、文件导入等特性。一般需要搭配`style-loader`使用，`css-loader`将`css`解析后并不会挂载到`html`页面中，`style-loader`可以将解析后的`css`内容挂载到`html`页面中。
- `style-loader`：将`css-loader`解析后的内容挂载到`html`页面中。
- `ts-loader`：将`typescript`转化为`javascript`。
### 常用plugin
- `HtmlWebpackPlugin`：简化`html`文件的创建，该插件会生成一个`html5`入口文件，文件中使用`script`标签引用外部资源和`webpack`包。如果项目有多个`webpack`入口点，这些入口点都会生成在`html`文件中的`script`标签内。
- `uglifyjs-webpack-plugin`：启用`ugligyjs`压缩`javascript`代码。`uglifyjs`是一个`javascript`解析器，可以压缩、美化`js`代码。`uhlifyjs`可以接受多个输入文件，然后按顺序解析输入文件并应用压缩选项。命令行用法：
```apl
uglifyjs [input files] [options]
```
- `webpack-parallel-uglify-plugin`：帮助具有许多入口点的项目加快其构建速度。随 `webpack`提供的`UglifyJS`插件在每个输出文件上按顺序运行。此插件并行运行`uglify`，每个可用`CPU`都有一个线程。这可以显著减少构建时间，因为缩小非常占用`CPU`资源。

### webpack性能优化

#### 合理配置`mode`参数
`mode `可以设置 `development `、`production`两个参数，如何没有设置，`webpack4 `会将 `mode `的默认值设置为 `production`。 `production `模式下会进行`tree shaking`去除无用代码 或者`uglifyjs`代码压缩混淆。

#### 缩小文件的搜索范围
*配置`includ、exclude、alias、noParse、extensions`*

- `alias `： 当我们的代码中出现 `import react` 式，`webpack `会采取向上递归搜索的方法去`node_modules`目录下找，为了减少搜索范围我们可以直接告诉 `webpack `去哪个路径下面找，也就是别名 `alias `的配置
- `include/exclude` ：配置 `include/exclude` 也可以减少 `webpack loader`的搜索、转换时间
- `noParse`：当我们代码中使用` import jq from 'jquery'` 时，`webpack `会去解析 `jq `这个库是否有依赖其他的包，但是我们对类似 `jquery `这类依赖库，一般会认为不会引用其他的包，增加 `noParse `属性，告诉 `webpack `不必解析，以此增加打包速度
- `extensions`：`webpack` 会根据 `extensions` 定义的后缀查找文件（频率较高的文件类型优先写在前面）

#### 使用 HappyPack 开启多进程 Loader 转换
在`webpack `构建过程中，实际上耗时时间大多数用在`loader`解析转换以及代码到的压缩中，日常开发中我们需要使用`Loader`对 `js`，`css`，图片,字体等文件做转换操作，并且转换文件数据量也非常大，由于`js `单线程的特性使得这些转换操作不能并发处理文件，而是需要一个个进行处理，`HappyPack`基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间。

#### 增强代码压缩
使用`webpack-parallel-uglify-plugin`增强代码压缩。

该`plugin`用于帮助具有多入口点的项目加快构建速度。随`webpack`提供的`UglifyJS`插件在每个输出文件上按顺序运行。此插件并行运行`uglify`，每个可用`CPU`都有一个线程。这可以显著减少构建时间，因为缩小非常占用`CPU`资源。

#### 抽离第三方模块
对于开发项目不经常会变更的静态依赖文件，类似于我们的`react`全家桶等，因为很少会变更，所以我们不希望这些依赖要被集成到每一次的构建逻辑中去，这样做的好处是每一次更改我本地的代码文件的时候， `webpack `只需要打包我项目本身的文件代码，而不会去编译第三方库。以后只要我们不升级第三方包，`webpack`就不会对这些库去打包，这样可以大幅提高打包的速度

#### 配置缓存
我们每次执行构建的都会把所有文件都重复编译一遍，这样的重复工作是否可以被缓存下来呢，答案是可以的。目前的大部分`loader`都提供了`cache`配置项，比如在`babel-loader`中，可以通过设置`cacheDirector`来开启缓存，`babel-loader?cacheDirectory=true` 就会将每一次的编译结果写进硬盘文件（默认是在项目根目录下的`node_modules/.cache/babel-loader`目录内，当然也可以自定义。

#### 优化打包体积
打包速度我们是进行优化了的，但是打包后的文件体积却是十分大，造成了页面加载缓慢，浪费流量等，接下来让我们从文件体积上继续优化。

- `externals`：如果我们想引用一个库，但是又不想让`webpack`打包，并且又不影响我们在程序以 `CMD`、`AMD `或者 `window/global` 全局等方式进行使用，那就可以通过配置 `Externals`。这个功能主要使用 在创建一个库的时候用的， 但是也可以在我们项目开发中充分使用`Externals`的方式，我们将这些不需要打包的静态资源从构建逻辑中剔除出去，而是使用`CDN`的方式，去引用它们。

- `Tree-shaking`：这里单独提一下`Tree-shaking`, 是因为这里有个坑，` tree-shaking` 的主要作用是用来清楚代码无用的部分，目前在`webpack4`我们设置`mode`为`production`的时候已经自动开启了`tree-shaking` ，但是要想使其生效，生成的代码必须是`ES6`模块，不能使用其他类型的模块如`Commonjs`之流。如果使用`Babel`的话，这里有一个小问题，因为`Babel`的预案`preset`默认会将任何模块类型都转译成`Commonjs`类型，这样会导致`tree-shaking` 失效，修改这个问题也很简单，在 `.babelrc` 文件或在`webpack.config.js`文件中设置 `modules: false`就好了。

#### webpack三种hash

1. `hash`：跟整个项目构建相关，构建生成的文件 `hash` 值都是一样的，只要项目中有文件更改，整个项目的 `hash` 值就会更改。
2. `chunkhash`：根据不同的入口文件（`entry`）构建相应的 `chunk`，生成对应的 `hash`值。
3. `contenthash`：由文件内容产生的 `hash` 值，内容不同产生的 `contenthash` 值也不一样。

### webpack使用proxy代理解决跨域
```js
 devServer: {
    proxy: {
      '/api': {              // 这里最好有一个 /
        target: url,         // 被代理的地址
        ws: true,            // 如果要代理 websockets，配置这个参数
        secure: false,       // 如果是https接口，需要配置这个参数
        changeOrigin: true,  // 是否跨域
        pathRewrite: { '^/api': '' }
      }
    }
  }
```
## vite
### vite使用proxy代理解决跨域
```js
proxy: {
  '/api': {
    target: 'http://localhost:7001', //被代理的地址
    changeOrigin: true,
    rewrite: path => path.replace(/^\/api/, '')
  }
}
```
- `target`：被代理的域名。
- `changeOrigin`：是否改写`http`请求`header`中的`origin`，改成跟`target`域名中的一样。
- `rewrite`：正则匹配`/api`，将其重写为空，这样后端就不用在每个接口上加上`/api`
## MVC/MVP/MVVM模式

`MVC、MVP、MVVM` 都是软件架构模式，通过分离关注点来改进代码的组织方式，也就是职责分离，将组织分层

### Model & View
- `Module` 层封装应用程序的业务逻辑相关的数据以及对数据的处理方法
- `View` 视图层，主要负责页面展示
### MVC
<img src="C:\Users\21133\Pictures\js\MVC.png" alt="MVC" style="zoom:67%;" />

- 一种软件架构模式，极大地降低了 `GUI（浏览器渲染进程中负责页面渲染的线程）` 应用程序的管理难度
- `MVC` 允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对 `View` 的操作交给了`Controller` 处理，在 `Controller` 中响应 `View` 的事件调用 `Model` 的接口对数据进行操作，一旦 `Model` 发生变化便通知相关视图进行更新。
- `MVC` 模式的业务逻辑主要集中在 `Controller`，而前端的 `View` 其实已经具备了独立处理用户事件的能力，当每个事件都流经 `Controller` 时，这层会变得十分臃肿。
#### Model（数据层）
- `Model` 层用来存储业务的数据，一旦数据发生变化，模型将通知有关的视图。
- `Model` 和 `View` 之间使用了观察者模式，`View` 事先在此 `Model` 上注册，进而观察`Model` ，以便更新在 `Model` 上发生改变的数据。
#### View（视图层）
- 数据展示
- `view` 和 `controller` 之间使用了策略模式，如果要实现不同的响应的策略只要用不同的`Controller` 实例替换即可
#### Controller（控制器）
- 控制器是模型和视图之间的纽带，`MVC`将响应机制封装在 `controller` 对象中，当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了。
### MVP

<img src="C:\Users\21133\Pictures\js\MVP.png" alt="MVP" style="zoom:67%;" />

- `MVP（Model-View-Presenter）` 是 `MVC` 模式的改良。
- 和 `MVC` 的相同之处在于：`Controller/Presenter` 负责业务逻辑，`Model` 管理数据，`View` 负责显示。
- 在 `MVC` 里，`View` 是可以直接访问 `Model` 的，但 `MVP` 中的 `View` 并不能直接使用`Model`，而是通过为 `Presenter` 提供接口，让 `Presenter` 去更新 `Model` ，再通过观察者模式更新 `View`。
#### Model
- `Model` 层依然是主要与业务相关的数据和对应处理数据的方法。 
#### View
- `MVP` 定义了`Presenter`和 `View` 之间的接口，用户对 `View` 的操作都转移到了`Presenter`。
- 可以让 `View` 暴露 `setter` 接口以便 `Presenter` 调用，待`Presenter` 通知 `Model` 更新后，`Presenter` 调用 `View` 提供的接口更新视图。
#### Presenter
- `View` 和 `Model` 之间的“中间人”
- 除了基本的业务逻辑外，还有大量代码需要对从 `View` 到 `Model` 和从 `Model` 到 `View`的数据进行“手动同步”，这样 `Presenter` 显得很重，维护起来会比较困难。
- 由于没有数据绑定，如果 `Presenter` 对视图渲染的需求增多，它不得不过多关注特定的视图，一旦视图需求发生改变，`Presenter` 也需要改动。
### MVVM
<img src="C:\Users\21133\Pictures\js\MVVM.png" alt="MVVM" style="zoom:67%;" />

- `ViewModel` 指 `Model of View` —— 视图的模型
- `MVVM` 把 `View` 和 `Model` 的同步逻辑自动化了
- `View` 和 `Model` 同步不再手动地进行操作，而是交给框架所提供的数据绑定功能进行负责，只需要告诉它 `View` 显示的数据对应的是 `Model` 哪一部分即可。
#### Model
- 在 `MVVM` 中，我们可以把 `Model` 称为数据层，因为它仅仅关注数据本身，不关心任何行为（格式化数据由 `View` 负责）
#### View
- 和 `MVC/MVP` 不同的是，`MVVM` 中的 `View` 通过使用模板语法来声明式的将数据渲染进`DOM`，当 `ViewModel` 对 `Model` 进行更新的时候，会通过数据绑定更新到 `View`
#### ViewModel
- 大体相当于 `MVC` 中的 `Controller` 和 `MVP` 中的 `Presenter`。集中了主要的业务逻辑。
- 进行了数据绑定。
- `View` 不给 `ViewModel` 提供接口，数据绑定自动同步，当 `Model` 发生变化，`ViewModel` 就会自动更新；`ViewModel` 变化，`Model` 也会更新。

## 移动端适配
### 1px问题
- `retina` 屏下 `1px` 相对于普通屏会显得比较粗，因为设备像素跟`css`像素不统一，如果`css`像素写为 1，当 `dpr = 2`时，就等于两个设备像素，`dpr = 3` 时就等于 3 个设备像素。
#### 解决方法
1. `transform: scale(0.5)`：在 `X、Y`轴上对元素进行缩放
	- 优点：编写简单
	- 缺点：如果实现四条边框的适配会比较麻烦，如果元素存在嵌套，会对子元素产生影响
```css
div {
	hieght: 1px,
	transform: scaleY(0.5)
}
```
2. `transform: scale(0.5) + 伪元素`
```css
.box {
	position: relative;
}

.box::after {
	content: '';
	position: absolute;
	bottom: 0;
	left: 0;
	right:0;
	border-top:1px solid #666;
	transform: scaleY(0.5)
}
```
3. `box-shadow`：利用`css`阴影来模拟边框
	- 缺点：存在阴影，视觉效果可能不太好。  
```css
.box {
	box-shodow: 0 1px 1px -1px rgba(0, 0, 0, 0,5)
}
```
#### 其他方法
- `viewport`：将页面进行缩小处理
- `border-image`：使用`1px`的图片来模拟边框
- `background-image`：使用`1px`的图片来模拟边框
- `linear-gradient`：通过线性渐变实现移动端`1px`的线
- `svg`：矢量图形在不同设备下具有伸缩性

# 浏览器

## 浏览器缓存

- 浏览器缓存可以理解为一个**资源副本**。当我们向服务器请求资源后，浏览器会根据情况将资源`copy`一份到本地，方便下次读取。
- 缓存与`localstorege`、`sessionstorage`等本地存储不同，本地存储更多的是**数据记录**，体量比较小。而缓存更多是为了减少资源请求，多用于存储文件，存储量相对较大。
- 缓存的作用：减少不必要的请求，有些资源长时间都不会发生改变（例如用户头像），如果每次都请求这些资源，一来增加了页面显示延迟，二来增大了服务器的压力。如果这些资源直接缓存在本地，每次就可以在读取加载本地资源，**减少了页面加载时长从而优化用户体验，也减少了流量消耗，减轻了服务器的压力**。

浏览器中最常用的缓存是强缓存和协商缓存：
强缓存和协商缓存属于`Http cache`，是开发中接触最多的缓存。

**强缓存**：直接从本地副本比对读取，***不去请求服务器***，返回的状态码是 **200**。

**协商缓存**：***会去服务器比对***，若没改变才直接读取本地缓存，返回的状态码是 **304**。

### 强缓存
当我们需要读取数据时（无论发不发送`http`请求），首先会通过相应的字段检查强缓存，这个阶段是不需要发送`http`请求的。

检查强缓存的字段有两种，一种是`http 1.0`的`Expires`字段，另一种是`http 1.1`的`Cache-Control`字段。
#### Expires字段
- 表示资源的过期时间，是一个**时间戳**，存在于服务器返回的响应头中。
- 当客户再次请求该资源的时候，会把客户端的时间戳与该时间戳进行对比，如果大于该时间戳则说明资源过期，否则直接使用该缓存资源
- 缺点：客户端和服务器时间可能不一致
#### cache-control
- 相对于`Expires`，`cache-control`没有采用设置具体过期时间点的方式，而是采用过期时长来控制缓存的有效期。
- `cache-control`是`http 1.1`中新增的字段，当`cache-control`和`Expires`都存在时，`cache-control`的优先级更高。
- `cache-control`是一个时间长度单位，单位是秒。
- 优点：不依赖于客户端的时间，可以准确地设置过期时间。
##### cache-control中的字段
1. `max-age`：表示资源过了多久之后失效，单位是秒。
2. `s-maxage`：与`max-gae`类似，比`max-age`优先级高，而且在代理服务器中只有`s-maxage`生效。
3. `public`：表示该资源可以被所有客户端和代理服务器缓存。
4. `private`：表示该资源仅能客户端缓存，与`public`只能取一个，默认值是`private`。
5. `no-cache`: 跳过当前的强缓存，发送`HTTP`请求，即直接进入协商缓存阶段。
6. `no-store`：非常粗暴，不进行任何形式的缓存，直接向服务器请求最新的数据。
```j
Cache-Control:private max-age=3600 s-maxage=3600 no-cache
```
#### pragma字段
该字段的值只有`no-cache`或者`no-store`，控制浏览器是否进行强缓存

`pragma`字段优先级很高，比`Expires`和`cache-control`更高，当三者同时出现时，优先使用`pragma`

### 协商缓存
强缓存失效之后，浏览器在请求头中携带相应的缓存`tag`来向服务器发请求，由服务器根据这个`tag`，来决定是否使用缓存，这就是协商缓存。

协商缓存的`tag`有两个：`Last-Modified` 和 `ETag`。这两者各有优劣，并不存在谁对谁有绝对的优势，跟强缓存的两个`tag`不一样。
#### Last-Modified
最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。格式如下：
```js
last-modified: Thu, 20 Dec 2018 11:36:00 GMT
```
浏览器如果再次请求该资源，请求头中会带有`if-modified-since`字段，值是上次请求服务器返回的`last-modified`值。服务器接收到请求后会拿着个字段和最后的资源修改时间作对比：

- 若时间一致说明资源未修改，返回 304 状态码，通知浏览器直接使用缓存
- 如果`if-modified-since`小于最后的修改时间，说明服务器资源较上次有更新，服务器返回最新的资源给浏览器，并更新`last-modified`的值。

`last-modified`有两个缺点：
1. 服务端资源只要编辑了，不管内容是否真的有改变都会以最后修改的时间作为判断依据，作为新的资源返回，导致了没必要的请求响应。
2. 时间的精度只能精确到秒，如果在一秒内对统一资源发送了多次请求，这一秒内服务端资发生的修改是检测不到的，仍会返回 304 通知浏览器使用缓存
#### etag字段
- `etag`会根据资源的内容生成一串编码作为资源的标识符，只要资源内容不同，生成的`etag`就不同，服务器通过响应头把这个值传给浏览器。格式如下：
```js
etag: "FllOiaIvA1f-ftHGziLgMIMVkVw_"
```
- 浏览器收到`etag`的值，会在下次请求时将这个值作为`If-None-Match`字段的内容，然后放到请求头中发送给服务器。
- 服务器接收到`If-None-Match`后，会跟服务器上该资源的`ETag`进行比对：
	- 如果二者不一致就说明服务器资源更新了，要返回新的资源给浏览器
	- 如果二者一致，说明资源未更新，服务器返回 304 状态码，通知浏览器使用缓存。
- `etag`优点：相对于`Last-Modified`，`eage`精度更高，能准确地感知资源的变化。当二者同时存在时，`eage`优先级更高。
- 缺点：性能不如`Last-Modified`，`etag`没次都要根据文件内容生成哈希串，增加了服务器的开销。
## ajax
- 全称`Asynchronous JavaScript and XML`。在`ajax` 出现之前，浏览器是通过带有`src`或者`href`属性的`script、img、link、a、iframe`标签以及`form`表单来向服务端请求数据的。这些请求只能拉取图片、`html`文档等资源，并且每次请求都会重新刷新页面，造成不必要的网络传输过程中的性能消耗。
- `Ajax`是一种异步请求数据的`web`开发技术，对于改善用户体验和用户性能有很大的帮助。
- `Ajax`向服务端请求的是数据而不是`html`文档，这样节省了网络带宽
- `ajax`使用`XMLHttpRequest`对象发起请求获得新数据，然后再通过`DOM`节点将新数据插入到页面中。
### xhr使用
```js
// 新建XMLHttpRequest对象
const xhr = new XMLHttpRequest()

xhr.onreadystatechange =  () => { 
  // 状态发生变化时，函数被回调
  if (xhr.readStae === 4) { // 成功完成
  	// 判断响应结果
  	if (xhr.status === 200) { 
  	  // 请求响应成功，返回拿到的响应文本
  	  return success(xhr.responseText)
  	} else {
  	  // 失败
  	  return fail(xhr.status)
  	}
  } else {
    // ...其他操作
  }
}

// 发送请求: 设置请求方法和请求地址
xhr.open('get', '/api/categories');
xhr.send(null);
```
- `xhr.onreadystatechange`：事件处理函数，当`readyState`改变时就会出发该事件。
- `xhr.readyState`：表示`xhr`所处的状态，一个`xhr`只能处于四种状态中的一种：
	- 0：`unsent（未初始化）`状态，创建了`xhr`，但是没有调用`open()`方法
	- 1：`opened（启动）`状态，`open()`已调用
	- 2：`headers_received（发送）`状态，`send()`方法已调用，并且头部状态已经可获得
	- 3：`loading（接收）`状态，下载中，`responseText`属性已经包含部分数据
	- 4：`done（完成）`状态，下载操作已完成。
- `xhr.responseText`：从服务端返回的响应文本。
- `xhr.responseXML`：如果相应的类型是`text/xml`或`application/xml`，这个属性将保存响应的`XML DOM`文档
- `xhr.status`：`http`响应返回的状态码
### axios
- `axios`对原生`xhr`进行了封装，是`promise`的实现版本，是一个能够同时在`node`和`浏览器`环境下运行的`http`客户端 ，符合最新的`es`规范。
- `axios`特征：
	1. 从浏览器中创建`xhr`
	2. 支持`promise`
	3. 客户端支持防止`csrf`攻击
	4. 可以在`node`环境下运行，发送`http`请求
	5. 支持请求和响应的拦截
	6. 可以转换请求和响应的数据格式
	7. 可以中途取消请求
	8. 自动转换`json`数据
#### axios封装
```js
// vite环境下
import axios from 'axios'
import { Toast } from 'zarm'
// 从vite中获取当前环境变量（开发环境||线上环境）
const MODE = import.meta.env.MODE
// 如果是开发环境用自己的ip地址，否则用服务器的ip
axios.defaults.baseURL = MODE === 'development' ? '/api' : ''
// 跨域请求时是否需要使用凭证
axios.defaults.withCredentials = true
// 自定义请求头类型
axios.defaults.headers['X-Requested-With'] = 'XMLHttpRequest'
// 配置请求携带的凭证
axios.defaults.headers['Authorization'] = localStorage.getItem('token') || null
// post请求的请求体json化
axios.defaults.headers.post['Content-Type'] = 'application/json'

// 响应拦截
axios.interceptors.response.use(res => {
  if (typeof res !== 'object') {
    Toast.show('服务器异常，请稍后再试!')
    return Promise.reject(res)
  }
  if (res.data.code !== 200) {
    if (res.data.msg) {
      message.error(res.data.msg)
    }
    if (res.data.code === 401) {
      window.location.href = '/login'
    }
    return Promise.reject(res.data)
  }
  return res
})

// axios封装
export const Ajax = (type = 'get', url, data) => {
  let promise
  if (type === 'get') {
    promise = axios.get(url, {
      params: data
    })
  } else if (type === 'post') {
    promise = axios.post(url, data)
  }
  return promise.then(res => {
    return res
  })
    .catch(error => {
      console.log(error)
    })
}
```
### fetch
- `fetch`不是`ajax`的进一步封装，是原生的`js`，没有使用`XMLHttpRequest`对象
- 优点：
	1. 符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象中。
	2. 语言简洁，更加语义化
	3. 基于`promise`实现，支持`async/await`
	4. 更加底层，提供了丰富的`api（request, response）`
	5. 脱离了 `xhr`，是`es`规范中新的实现方式
- 缺点：
	1. 只能捕获到请求过程中的错误，状态码 400、500 都被当做成功的请求，不会`reject`，只有网络请求不能完成时才会`reject`
	2. 默认不携带`cookie`，需要添加配置项`fetch(url, {credentials: 'include'})`
	3. `fetch`发送的请求不能中止，不支持超时控制，使用定时器等不能阻止请求
	4. 原生不能检测请求的进度

# 网络协议

## OSI七层协议模型

1. 物理层：解决硬件之间的通信问题，以各种媒介（光纤、电缆等）传输比特流。网络信号（0/1）转化为电信号（电流强弱）进行传输，到达目的地后再转化成网络信号。这一层的数据叫**比特**。
2. 数据链路层：通过各种控制协议把由差错的物理信道变成无差错的、能可靠传输数据帧的数据链路。接受来自物理层的位流形式的数据，封装成帧传输到上一层；上层的数据帧拆分为位流形式的数据转发到物理层。这一层数据叫做**帧**。
3. 网络层：计算机网络中有多台设备时如何找到要发请求的那一台，中间有多个节点又要如何选择路径？网络层使用路由选择算法，通过通信子网为**报文**（网络层的数据单位，由上一层数据打包而来）选择最适当的路径。网络层定义的是`IP`地址，通过`IP`地址寻找地址，所以产生了`IP`协议。
4. 传输层：数据传输量较大时，很可能出现丢包的情况，接受数据的设备要告诉是否完整接收到全部数据，如果数据有缺失就要告诉丢了哪些包，然后再发一次，直到全部接受为止。
5. 会话层：每次传输去调用传输协议打包、调用`IP`协议找路由很低效。会话层有自动发包、自动寻址的功能。会话层作用是建立和管理应用程序之间的通信。
6. 表示层：负责数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将下一层的数据转化为上层能处理的格式。
7. 应用层：应用层是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。

## TCP/IP 四层模型
`OSI`七层模型是理论上的分层方式，`TCP/IP`四层模型是实践过程中的分层模型。`TCP/IP`四层模型如下：

1. 网络访问层：对应`OSI`中的 物理层+数据链路层。该层主要是管理物理网络准备所需要的数据，包括：
- 与计算机网络适配器连接。
- 根据合适的方式调整传输。
- 把数据转化为电子流或者脉冲的形式在传输介质上传输。
- 对发送的数据添加错误检查信息、对接受的数据进行数据校验。
2. 网际层：对应`OSI`的网络层。网际层主要是制定了由一个计算机的`IP`如何到目标计算机的过程规范。计算机设备请求发送后经过哪些处理才能正确找到目标设备，其中包含了`IP、ARP、RARP、ICMP`等协议。
- `MAC`地址：每台计算机设备都有一个唯一的地址标识，这个标识就是`MAC`地址（也叫网络适配器地址）。网络适配器地址由厂商生产的时候规定的一个复杂英文串组成。
- `IP`地址：`MAC`地址太复杂，不利于计算机进行逻辑运算。`IP`地址是一套有规则的数字组成的，通过`IP`地址可以快速定位到目标计算机区域，和`MAC`地址组合就能快速找到网络中具体的一台计算机了。
- 域名：`IP`地址过长不方便记忆，为了用户方便记忆就衍生出`DNS`服务，将`IP`地址转为方便记忆的域名地址。
3. 传输层：对应`OSI`的传输层。传输层提供了应用程序接口，为网络应用程序提供网络访问的途径；提供可以从多个应用程序接收消息的功能（多路复用），同时也提供可以把消息分发给应用程序的功能（多路分解）；对数据进行进行错误检测、流量控制。
4. 应用层：对应`OSI`的应用层、会话层、网络层。应用层为用户提供服务并支持网络访问；会话层负责管理网络中计算机之间的通信，提供传输层不具备的连接相关功能；表示层负责数据格式转化，处理、加密、压缩数据。

## TCP三次握手四次回收
### 三次握手
`TCP`三次握手是为了防止已经失效的连接请求报文突然又传到服务端而产生错误。问题的本质是：信号传输信道是不可靠的，但我们需要保障数据的传输是可靠的，三次握手是一个理论上的最小值，是为了满足在不可靠的信道上传输可靠的数据所要求的。

1. 第一次握手：客户端给服务器发送一个`SYN`段（`TCP`标头中`SYN = 1` 的 `TCP/IP`数据包），该段中包含了客户端的初始序列号（`Sequence number = x`），此时客户端处于`SYN_SEND`状态。`SYN`是同步的缩写，`SYN`是发送到另一台计算机的`TCP`数据包，请求在它们之间建立连接。
2. 第二次握手：服务器给客户端返回`SYN + ACK`段（`TCP`标头中`SYN = 1, ACK = 1`的字段），该段中包含服务器的初始序列号（`Sequence number = y`）；同时使确认号`Acknowledgment number = x + 1`来表示确认已经收到客户端的`SYN`字段（`Sequence number = x`）。`ACK`是“确认”的缩写，`ACK`数据包是确认收到一条消息或者一系列数据包的`TCP`数据包。此时服务器处于`SYN_REVD`状态
3. 第三次握手：客户端给服务器响应一个`ACK`字段（`TCP`标头中`ACK`字段为1的`TCP/IP`数据包），该段使`Acknowledgment number = y + 1`表示确认已经收到服务器的`SYN`字段（`Sequence number = y`）。此时客户端处于`establised`状态。

*为什么需要三次握手？两次握手为何不行？*
- 第一次握手：客户端发送网络包，服务器收到，这样服务器就能得出结论——***客户端的发送能力***、***服务端的接收能力***是正常的
- 第二次握手：服务端发包，客户端收到，客户端得出结论——***服务端接受、发送能力***正常，***客户端接受、发送能力***正常。不过此时服务器不能确认***客户端接收能力***是否正常。
- 第三次握手：客户端发包，服务端收到，服务端得出结论——***客户端发送、接收能力***正常，服务端自己的发送、接受能力也正常。

如果是两次握手，有可能出现以下情况：
> 客户端发送请求连接，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。客户端后来收到了确认，建立了连接。数据传输完毕后就释放了连接，客户端共发送了两个连接请求报文，其中第一个丢失，第二个到达了服务端。但第一个丢失的报文段只是在*某些网络节点长时间滞留了，延误到连接释放后的某个时间才到达服务端*，此时服务端误认为客户端又发送一次新的连接请求，同意建立连接。不采用三次握手，只要服务端发出确认，就建立了新的连接，此时客户端忽略服务端发来的确认，也不发送数据，服务端一直等待客户端发送数据，浪费资源。

### 四次挥手
*四次挥手是由`TCP`的**半关闭**造成的，所谓半关闭就是`TCP`协议给通信双方提供的一种能力：某一端（无论客户端还是服务端）在结束发送之后还可以接受另一端的数据。*

四次挥手开始前，服务端和客户端都处于`establised`状态，`TCP`连接的拆除需要发送四个包，因此称为四次挥手，假如是客户端发起关闭请求，过程如下：
1. 第一次挥手：客户端发送一个`FIN`报文，报文中会指定一个序列号。此时客户端处于`FIN_WAIT1`状态。即发出**连接释放报文段**（`FIN = 1, 序号seq = u`），并停止再发送数据，主动关闭`TCP`连接，进入`FIN_WAIT1`（终止等待1）状态，等待服务器确认。
2. 第二次挥手：服务端收到`FIN`之后，会发送`ACK`报文，并把客户端序列号 `+1` 作为`ACK`报文的序列号值，表明已经收到客户端报文，此时客户端处于`CLOSE_WAIT`状态。即服务端收到**连接释放报文段**之后发送**确认报文段**（`ACK = 1, 确认号ack = u + 1, 序号seq = v`），服务端进入`CLOSE_WAIT`（关闭等待状态），此时`TCP`处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入`FIN_WAIT2`状态，等待服务端发出的连接释放报文段。
3. 第三次挥手：如果服务端也想断开连接了，和客户端第一次挥手一样，发给`FIN`报文，且指定一个序列号。此时服务端处于`LAST_ACK`的状态。即客户端没有向客户端发起的数据，服务端发出**连接释放报文**（`FIN = 1, ACK = 1, 序号seq = w, 确认号ack = u + 1`），服务端进入`LAST_ACK`（最后确认状态），等待客户端的确认。
4. 第四次挥手：客户端收到`FIN`之后，一样发送一个`ACK`报文作为应答，且把服务端的序列号值 `+1` 作为自己`ACK`报文的序列值，此时客户端处于`TIME_WAIT`状态。需要过一阵子以确保服务端收到自己的`ACK`报文之后才会进入`CLOSED`状态，服务端收到`ACK`报文之后，就处于关闭连接了，处于`CLOSED`状态。即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（`ACK = 1, seq = u + 1, ack = w + 1`），客户端进入`TIME_WAIT`（时间等待）状态。此时`TCP`未释放掉，需要经过时间等待计时器设置的时间`2MSL`后，客户端才进入`CLOSED`状态。

*为什么需要四次挥手？*
当服务端收到客户端的`SYN`连接请求报文后，可以直接发送`SYN + ACK`报文。其中***`ACK`报文是用来应答的，`SYN`报文是用来同步的。***但是关闭连接时，当服务端收到`FIN`报文时，很可能并不会关闭`SOCKET`，所以只能先回复一个`ACK`报文，告诉客户端，“你的`FIN`报文我收到了”。只有等到我服务端所有的报文都发送了，我才能发送`FIN`报文，因此不能一起发送。故需要四次挥手。
## 根据层级划分协议

### 应用层

- HTTP 
- FTP
- SMTP
- telint
- DNS
- tftp

### 传输层

- `TCP`：`TCP`相当于“握手对话”，面向连接，`TCP`连接3次握手、断开4次挥手
- `UDP`：`UDP`相当于“广播”，面向无连接
  <img src="C:\Users\21133\Documents\B-JS\js知识点\js知识点图解\TCP-UDP.png" alt="TCP-UDP" style="zoom: 67%;" />

### 网络层

- IP

## http

### 什么是http
- `http（Hypertext Transfer Protocol）`全称**超文本传输协议**，是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。
### http状态码
当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含`HTTP`状态码的信息头（server header）用以响应浏览器的请求。`HTTP`状态码的英文为`HTTP Status Code`。
下面是常见的`HTTP`状态码：

- 100：继续。客户端应继续请求。一般服务器接收到`POST`请求头时返回此状态码
- 200：请求成功
- 301：资源（网页等）被永久转移到其它`URL`，永久重定向，客户端自动定向到新的 `url`，以后的请求都会被新的 `url` 替代
- 302：临时重定向，资源暂时被转移，用户应该继续使用原 `url`
- 304：未修改。所请求的资源未修改，不会返回任何资源。详见 https://www.cnblogs.com/gxw123/p/13288320.html	
- 400：客户端请求的语法错误，服务器无法理解
- 401：请求要求用户的身份认证
- 403：服务器理解请求，但拒绝执行该请求，一般是鉴权失败
- 404：请求的资源（网页等）不存在
- 407：请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权
- 500：内部服务器错误
- 501：服务器不支持请求的功能，无法完成请求，有的服务器只支持 `get/post`请求
- 503：服务器超载，暂时无法处理请求，延时的长度可包含在服务器的`Retry-After`头信息中
#### HTTP状态码分类
HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：
- 1xx	信息，服务器收到请求，需要请求者继续执行操作
- 2xx	成功，操作被成功接收并处理
- 3xx	重定向，需要进一步的操作以完成请求
- 4xx 	  客户端错误，请求包含语法错误或无法完成请求
- 5xx	服务器错误，服务器在处理请求的过程中发生了错误

[http状态码列表](https://www.runoob.com/http/http-status-codes.html)

## https
### http的问题
`hppt`传输信息是明文传输，任何人都可能从中截取、修改或者伪造请求的发送。

- 明文传输，别人可以窃取传输的内容。
- 没有**用户验证**，`http`信息交换的双方身份可能被伪造。
- 信息发送方和接收方不会**验证报文的完整性**，传输信息有可能被篡改

### SSL/TLS协议
- `TLS(Transport Layer Security)` 是 `SSL(Secure Socket Layer)` 的后续版本，它们是用于在互联网两台计算机之间用于身份验证和加密的一种协议。设计的`SSL/TLS`协议设计出来就是为了解决`http`协议传输信息的风险和问题。
- `SSL/TLS` 通过将称为 `X.509` 证书的数字文档将网站和公司的实体信息绑定到加密密钥来进行工作。每一个**密钥对(`key pairs`)** 都有一个 **私有密钥(`private key`)** 和**公有密钥(`public key`)**，私有密钥是独有的，一般位于服务器上，用于解密由公共密钥加密过的信息；公有密钥是公有的，与服务器进行交互的每个人都可以持有公有密钥，用公钥加密的信息只能由私有密钥来解密。
- `SSL/TLS`希望达到的效果：
	1. 所有信息都是**加密传播**，第三方无法窃听。
	2. 具有**校验机制**，信息一旦被篡改，通信双方会立刻发现。
	3. 配备**身份证书**，防止身份被冒充。
#### x.509
`x.509`是公开密钥证书的标准格式，这个文档将加密秘钥与个人（组织）进行安全的关联。
`x.509`主要应用如下：

1. `SSL/TLS`和`HTTP`用于身份验证和加密的 `Web` 浏览
2. 通过`S/MIME`协议签名和加密的电子邮件
3. 代码签名：使用数字证书对软件应用程序进行签名以安全分发和安装的过程。通过使用由知名公共证书颁发机构（例如`SSL.com`）颁发的证书对软件进行数字签名，开发人员可以向最终用户保证他们希望安装的软件是由已知且受信任的开发人员发布；并且签名后未被篡改或损害。
4. 用于文档签名
5. 用于客户端认证 ... 

### 密码学几个概念
- 明文(`Plaintext`)：一般认为明文是有意义的字符或者比特集，或者是通过某种公开编码就能获得的消息，通常用 m 或 p 表示
- 密文(`Ciphertext`)，对明文进行某种加密后就变成了密文
- 加密(`Encrypt`)，把原始的信息（明文）转换为密文的信息变换过程
- 解密(`Decrypt`)，把已经加密的信息恢复成明文的过程
### 对称加密
- 加密和解密时使用的密钥都是同样的密钥。只要保证了密钥的安全性，那么整个通信过程也就是具有了机密性。
- 加密方必须对原始数据进行加密，然后再把密钥交给解密方进行解密，解密方才能解密数据。
- 优点：算法公开、计算量小、加密速度快、加密效率高。
- 缺点：对称加密的秘钥一旦被泄露或者被劫持下来，加密的信息就不安全了。

### 分组加密（AES）
- 将明文分成N个组，然后对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。
- `AES`可以让算法用固定长度的密钥加密任意长度的明文。

### 非对称加密
- 非对称加密又称为**公钥加密**，公钥加密中有两个秘钥，一个是**公钥**，另一个是**私钥**
- 使用公钥加密的文本只能使用私钥解密，同时，使用私钥加密的文本也可以使用公钥解密。
- 公钥进行加密，私钥进行解密。公开密钥可供任何人使用，在网络间进行传输。私钥只有持有者自己能够知道。
- 非对称加密可以解决密钥交换的问题。
- 在`SSL/TSL`协议中，公钥被放在**数字证书**中，只要证书是可信的，公钥就是可信的。
### 非对称加密算法（RSA）
非对称加密常见算法有`DH`、`DSA`、`RSA`、`ECC`等，其中最出名的是`RSA`。
`RSA`原理：

-  将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将两个大素数乘积公开作为加密密钥（公钥）
`ECC原理`：
- 基于**椭圆曲线离散对数**的数学难题，使用特定的曲线方程和基点生成公钥和私钥，`ECDHE`用于密钥交换，`ECDSA`用于数学签名。

##### 公钥私钥制作过程
1. 选取两个质数：`p = 3; q = 11`
2. 质数相乘：`N = p * q = 33`，该数在公钥私钥中都有，作为加密解密求余的数字
3. 欧拉函数：`T = (p - 1) * (q - 1) = 2 * 10 = 20`
4. 选取公钥`E`，公钥必须是质数且满足`(1 < 公钥 < T)&&(不是T的因子)`，例如选取`E = 7`
5. 计算私钥`D`：`(D * E) % T = 1`，此处可以算出`D = 3`

***公钥中会包含`E = 7`这一项，该项是公开的，用于加密报文；私钥中含有`D = 3`这一项，该项是私密的，只有接收方拥有。私钥的计算过程很复杂，如果选取的两个质数非常大，那么破解私钥几乎是不可能的，所以`RSA`算法获得的私钥可以保障数据传输的安全性。***

##### 加密解密步骤
以上述选取的公钥和私钥为例：
**公钥`(7, 33)`**，**私钥`(3, 33)`**
原数据：`3, 1, 15`
***加密步骤如下***：

1. **求幂**，使用公钥第一项对原数据求幂
```js
3 ^ 7 = 2187
1 ^ 7 = 1
15 ^ 7 = 170859357
```
2. **求余**，使用公钥第二项对第一步的得到的数字求余
```js
2187 % 33 = 9
1 % 33 = 1
170859357 % 33 = 27
```
最后的密文就是`9, 1, 27`

***解密步骤如下***：
接受到密文`9 , 1, 27`

1. **求幂**，使用密钥第一项对密文求幂
```js
9 ^ 3 = 729
1 ^ 3 = 1
27 ^ 3 = 19683
```
2. **求余**，使用密钥第二项对密文求余，得到结果
```js
729 % 33 = 3
1 % 33 = 1
19683 % 33 = 15
```

如果把公钥和私钥的第一项调换效果是一样的，因为公钥第一项和私钥第一项是通过`RSA`算法产生的，它们之间是有特殊关系的。

### 混合加密

- 非对称加密算法（`RSA`）虽然安全性很高，但运算速度非常慢，而对称加密的`AES`算法比较快。
- 混合加密结合了这两种算法，在通信刚开始的时候使用非对称加密算法，实现解决**密钥交换**的问题。然后再用随机数产生对称算法需要的**会话密钥**，再用**公钥加密**。接受方拿到密文后再用**私钥解密**，取出会话密钥，这样双方就实现了对称加密的安全交换。
- `TLS`在混合加密的基础加上了**完整性、身份认证**的特性，实现了真正的安全，实现完整性的手段是**摘要算法**
### 摘要算法
- `MD5`：全称`Message Digest Algorithm 5`，是**密码哈希算法**的一种，常用于验证文件的完整性。

## get与post区别
对于`http`协议标准而言，`get`和`post`本质上没有区别，要说区别就只有一个：`get`请求的响应体浏览器会主动缓存，而`post`请求不会，需要手动设置。

实际上，在`http`协议中，`method`和`Date`是正交的两个概念，也就是说，使用哪个`Method`与应用层的数据如何传输没有关系。`http`没有要求`post`数据要放在`body`中，也没有要求`get`数据要放在`url`中而不能放在`body`中，`body`与请求方法无关，不是`post`请求专属的。

对于前端开发而言，`HTML`定义了一套标准，在这套标准中，`get`和`post`请求可以看做是不同的请求规范，对此，它们有如下区别：
1. `get`请求的数据拼接在`url`中，没有私密性，而`url`的长度是有限制的，而且`url`编码格式是固定的；而`post`请求的数据是放在请求体中，随外界而言请求体是不可见的，请求体的编码格式不受限制。
2. `get`请求的响应体会被浏览器主动缓存，因此`get`请求在浏览器回退时是无害的，而且`get`请求的参数会被完整地保留在浏览器历史记录中；`post`请求的响应体浏览器不会主动缓存，需要手动设置，因此`post`请求的参数浏览器也不会保留。

## xss攻击
- 全称`Cross Site Scripting（跨站脚本）`，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如`Cookie、SessionID`等，进而危害数据安全。
- `xss`本质：代码没有过滤和网站正常的代码混在一起，浏览器无法区分哪些代码是可信的，导致恶意脚本被执行。

### xss注入方法
1. 在`HTML`内嵌文本中，恶意内容以`script`标签形成注入。
2. 内联`javascript`中，拼接的数据突破了原本的限制（字符串、变量，方法名等）。
3. 标签属性中，恶意内容包含引号，从而突破属性值得限制，注入其他属性或标签。
4. 在标签的`href、src`属性中包含`javascript`等可以执行的代码。
5. 在`onload、onerror、onclick`等事件中，注入不受控制代码。
6. 在`style`属性和标签中，包含类似`background-image:url("javascript...")`的代码，新版本浏览器可以自己防范。
7. 在`style`属性和标签中，包含类似`expression(...)`的`css`表达式代码，新版本浏览器可以自己防范

总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到`HTML`中，这很容易造成注入漏洞。攻击者可以利用漏洞构造出恶意的代码指令，进而利用恶意代码危害数据安全。
### 三种类型的xss
`xss`攻击有三类：反射性`xss`（非持久型）、存储型`xss`（持久型）和`DOM xss`

#### 反射型xss
发送请求时，`xss`代码出现在`url`中，作为出入提交到**服务器端**，服务器端解析后响应，`xss`代码随着响应内容返回给浏览器，最后浏览器解析执行`xss`代码，整个过程就像一次反射，估称为反射型`xss`。
反射型`xss`的攻击步骤：
1. 攻击者构造出特殊的`url`，其中包含恶意代码。
2. 用户打开带有恶意代码的`url`时，网站服务端将恶意代码从`url`中取出，拼接在`HTML`中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

#### 存储型xss
存储型`xss`和反射型`xss`的区别：提交的代码会存储在服务器端（数据看、内存、文件系统等），下次请求页面时不用再提交`xss`代码；反射型`xss`放在`url`中。反射型`xss`常见于通过`url`传递参数的功能，入网站搜索、跳转等。由于需要用户主动打开恶意的`url`才能生效，攻击者往往会结合多种手段诱导用户点击。
存储型`xss`的攻击步骤：
1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在`HTML`中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

#### DOM型xss
`DOM`型`xss`攻击步骤：
1. 攻击者构造出特殊的`url`，其中包含恶意代码。
2. 用户打开带有恶意代码的`url`。
3. 用户浏览器接收到响应之后解析执行，前端`javascript`取出`url`中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
`DOM`型`xss`和前两种`xss`的区别：`DOM`型`xss`攻击中，取出执行恶意代码由浏览器完成，与服务器端无关，属于前端`javascript`自身的安全漏洞，而其他两种`xss`都属于服务器端的漏洞。
### xss攻击预防
`xss`攻击有两大要素：攻击者提交恶意代码；浏览器执行恶意代码。

- 针对第一个要素可以进行输入过滤：在用户输入过程中过滤掉用户输入的恶意代码。
- 针对第二个要素需要放置浏览器执行恶意代码：
	1. 防止`HTML`出现注入
	2. 防止`javascript`执行恶意代码
#### 输入过滤
- 对明确的输入类型，例如数字、`url`、电话号码、邮件地址等等内容进行输入过滤是必要的。
- 在用户提交数据时由前端进行过滤是不行的，一旦攻击者绕过前端过滤直接构造请求，就可以提交恶意代码。
- 在后端写入数据库前对输入进行过滤，然后把安全的内容返回给前端，这样可以在某些特定情况下解决`xss`问题，但会引入很大的不确定性。因为我们并不知道后端返回的内容要输出到哪里：
	- 用户输入的内容有可能同时提供给前端和客户端，一旦经过了`escapeHTML()`，客户端显示的内容就变成了乱码。
	- 在前端中，不同位置所需要的编码也不同。当返回的数据作为`HTML`拼接页面时可以正常显示。如果以`ajax`返回然后赋值给`javascript`变量，前端得到的字符就是转义后的字符。这个内容不能作为`jsx`等模板的展示，也不能直接用于标题、`alert`等。 
#### 预防存储型和反射型xss
存储型和反射型`xss`都是服务端取出恶意代码后插入到响应`HTML`里的，攻击者编写的数据被内嵌到代码中被浏览器执行。预防这两种漏洞，有两种常见的做法：
1. 改成纯前端渲染，把代码和数据分开。编写代码过程中明确告诉浏览器哪些内容是文本（`.innerText`）、哪些内容是属性（`.setAttribute`）、哪些内容是样式（`.style`）。这样浏览器就不会轻易被欺骗，执行预期之外的代码了。
2. 对`HTML`做充分的转义。使用合适的转义库或者模板引擎，在不同的上下文中要使用相应的转移规则。
#### 预防DOM型xss
`DOM`型`XSS`攻击，实际上就是网站前端`JavaScript`代码本身不够严谨，把不可信的数据当作代码执行了。

- 在使用`.innerHTML、.outerHTML、document.write()`时要特别小心，不要把不可信的数据作为`HTML`插到页面上，而应尽量使用`.textContent、.setAttribute()`等。
- 使用`react`技术栈，保证不直接操作`DOM`，避免创建`innerHTML、outerHTML`的`xss`隐患
- `DOM`事件监听器、`setTimeout()、setInterval()`、`<a> 标签的 href 属性`等都能把字符串作为代码运行，不要在字符串中拼接不可信的数据。

## csrf攻击
全称`Cross Site Request ForGery（跨站域请求伪造）`，别称`xsrf`，是一种网络的攻击方式。

`csrf`通过**伪造来自受信任用户**的请求来攻击受信任的网站。简单来说，`csrf`盗取用户身份，以该用户名义发送恶意请求，造成个人隐私泄露甚至财产安全。

### csrf原理

<img src="C:\Users\21133\Pictures\js\csrf.png" alt="csrf" style="zoom:60%;" />

要完成一次`csrf`攻击，受害者必须一次完成两个步骤：

1. 登录受信任网站 A，并在本地生成`cookie`
2. 在不登出 A 的情况下，访问危险网站 B

以上两个条件任意一个不满足`csrf`攻击就不能完成。但是用户不能保证以下情况不发生：

- 用户不能保证登录一个网站后不打开新的`tab`页访问另一个网站。
- 用户不能保证关闭浏览器后本地`cookie`立刻过期。
- `csrf`攻击不只是危险网站能发出，也可能是一个有其他安全漏洞的受信任网站发出的。
因此 `csrf`攻击很难防范，危险系数很高。
### 常见csrf类型

- `GET`型`csrf`：获取带有`src`属性的标签，将其`src`属性替换为存在`GET`型``csrf`的地址。
```html
<img src=http://wooyun.org/csrf?xx=11 /> 
<-- 将该 img 的 src 替换为危险网站就完成了 csrf 攻击 -->
```
- `POST`型`csrf`：利用自动提交的表单，将`form`表单的`action`属性替换为危险地址就完成了攻击
```html
<form action=http://wooyun.org/csrf.php method=POST>
<input type="text" name="xx" value="11" />
</form>
```
- 其他类型还有例如有基础认证的`csrf`，可以攻击路由器。

### csrf防御
- `csrf`之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 `cookie` 中，黑客可以在不知道这些验证信息的情况下直接利用用户自己的 `cookie` 来通过安全验证。
- 要抵御 `CSRF`，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 `cookie` 之中。
- 防御`csrf`攻击主要有三种策略：
    - 验证`Http Referer`字段
    - 请求添加`token`验证
    - `Http`头部自定义属性并验证

#### 验证 Http Referer
- 该字段记录了`Http`请求的来源地址，网站对每个请求都验证`Referer`字段的值。
- 优点：简单易行，只需要给所有安全敏感的请求统一加上拦截器检查`Referer`的值
- 缺点：`Referer`是浏览器提供的，这样请求的安全性全靠浏览器保障，但浏览器自身也肯能会有安全漏洞，有些浏览器甚至可以篡改`Referer`的值（`IE6`）。
#### token验证
- 在`http`请求中添加一个随机产生的`token`，在服务端添加拦截器验证这个`token`。`token`可以在用户登录后存放在`session`中，后续每次请求都拿出`token`来进行校验。
- 优点：安全性比`Referer`更高。
- 缺点：将`token`以参数的形式加入请求会比较麻烦，因为一个网站中可接受请求的地方非常多，对每个请求都加上`token`比较麻烦，容易漏加。而且`token`本身也不是百分百安全，在一些论坛网站，黑客可以在上面发布自己的网址，系统也会在这个地址上加上`token`，黑客就能在自己网站上得到`token`发动`csrf`攻击。
#### 自定义HTTP头
- 这种方法也属于`token`验证，但是这个`token`是作为参数放在`http`请求中，而是放在`http`头部的自定义属性中。
- 优点：可以一次性给所有请求加上`http`头部属性，解决了`token`加入不方便的问题。而且`xhr`请求的地址不会被记录到浏览器的地址栏，也不用担心`token`泄露到其他网站。
- 缺点：局限性很大，`Ajax`用于对页面的局部刷新，并非所有请求都适合`xhr`，而且请求不能被浏览器记录，网页就不能收藏、前进、后退，用户体验不好。对于没有部署`csrf`防护的系统来说，要是用这种防护需要把所有的请求都改为`xhr`，这几乎需要重构整个网站，代价太大。

## cookie

`cookie`是一种浏览器管理状态的一个文件，它有`name`、`value`等属性。

`cookie`运作原理：第一次访问网站时，浏览器发起请求，服务器响应之后，可以生成`cookie`并将其放入到响应体中。浏览器下次发送请求时，就会携带`cookie`，服务端就能根据`cookie`辨别用户身份。当然服务器也可以修改`cookie`的内容。

![](C:\Users\21133\Pictures\js\cookie.png)

**注意**：`cookie`是不可跨域的。

### cookie的属性

- `name`：`cookie`的名字，一个域名下绑定的`cookie`，`name`不能相同，相同的`name`的值会被覆盖掉。
- `value`：`cookie`的值。`cookie`规定对分号、逗号、空格必须编码，为了不给用户添麻烦，考虑服务器的兼容性，任何存储`cookie`的数据都应该被编码。
- `domain`：表示`cookie`绑定的域名，如果没有设置，就会自动绑定到执行语句当前域。统一域名下的二级域名也是不可以交换使用`cookie`的，例如`www.baidu.com`和`img.baidu.com`的`cookie`依然不能公用。
- `path`：这个属性值默认是`/`，匹配的是`web`路由。
- `secure`：设置是否启动安全状态，`http`不仅无状态，还不安全，容易被劫持。当该属性设置为`true`时，此`cookie`只会在`https`和`ssl`等安全协议下传输。注意该属性不能对客户端的`cookie`进行加密，不能保证绝对的安全性。
- `HttpOnly`：这个值设置为`true`时，就不能通过`js`脚本来获取`cookie`的值，能有效防止`xss`攻击。也就是说该属性设置为`true`后就不能通过`document.cookie`、`XMLHttpRequest`对象获取`cookie`。

### cookie的作用域

`domain`和`path`表示定义了`cookie`的作用域：即`cookie`应该发给哪些`url`。

`domain`指定了哪些主机可以接受`cookie`。如果不指定，默认为当前主机（不包含子域名）。

`path`指定了`web`路由

例如访问`https://juejin.cn/post`，则`domin`是`juejin.cn`，而`path`指的是`/post`。


### cookie有效期

一般浏览器的`cookie`是默认存储的，当浏览器关闭结束这个会话时，`cookie`就会被删除。

如果想要人为控制`cookie`的有效期，有两个属性可以设置：

1. `Expires`：设置`cookie`在未来过期的时间点，到了这个时间就过期，不过服务器和浏览器时间可能有误差，这个属性自然就有误差。
2. `Max-Age`：以秒为单位，当`max-age`为正数时，`cookie`就会在`max-age`秒后被删除；当`max-age`为负数时，表示临时存储，不会生成`cookie`文件，只会存在浏览器内存中，一旦浏览器关闭，`cookie`就会消失；当`max-age`为 0 时，`cookie`会立刻失效被浏览器删除，所以想要让`cookie`立即失效就可将`max-age`设置为 0。




### 操作cookie

- 在`html`文档中可以通过`document.cookie`获取到`cookie`并进行设置修改。
- 服务端使用`setCookie()`这个`api`即可设置`cookie`。

## 跨域
跨域是浏览器的同源策略导致的，同源策略是浏览器最基本的安全功能，如果缺少同源策略，浏览器很容易受到`xss`、`csrf`等攻击。

什么是同源？以下是`MDN`对同源的描述：
> 如果两个`url`的`protocol（协议）`、`port（域名）`、`host（端口）`都相同，则这两个`url`是同源。

`http`默认情况下占用`80`端口，`https`占用`443`端口，一般写`url`会省略端口。
例如`http://www.baidu.com/a.js`其实是`http://www.baidu.com:80/a.js`。
在这个`url`中，`http://`是协议，`www.baidu.com`是域名，`:80`是端口，后面的就是请求路径、请求参数、锚点之类的了。 

同源策略就是限制不同源之间的交互。

## 跨域身份认证

### 用户认证一般流程
1. 用户向服务器发送用户名和密码。
2. 服务器验证通过后，在当前对话（`session`）里面保存相关数据，比如用户角色、登录时间等等。
3. 服务器向用户返回一个`session_id`，写入用户的`Cookie`（`Cookie.setValue(...)`）。
4. 用户随后的每一次请求，都会通过`Cookie`，将`session_id`传回服务器。
5. 服务器收到`session_id`，找到前期保存的数据，由此得知用户的身份。

这种模式有缺点：扩展性不好，如果是服务器集群就要求`session`数据共享，使得每台服务器都能够读取`session`。解决方法有两种
- `session`持久化，写入数据库或别的持久层，服务器收到请求后向持久层请求数据。优点是架构清晰，缺点是工作量大，而且一旦持久层挂了就会单点失败。
- 服务器不存储`session`数据，所有数据保存在客户端，每次请求都发回服务器，`JWT`就是这种方案的一个代表。

### jwt

- 全称`Json Web Tokens`，是一种解决跨域身份认证的方案

#### jwt原理

- 服务器认证之后生成一个`JSON`对象，将该对象加密成`token`返回给用户。
- 用户收`token`之后的每次请求都要在请求头的`authorization`字段带上这个`token`，服务器就靠这个`token`认定用户身份。
- 为防止用户篡改数据，服务器在生成这个对象的时候会加上签名。
#### jwt的详细内容
- `jwt`是一个很长的字符串，中间用符号`.`分隔成三部分，格式大致如下：
```js
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJpZCI6MSwidXNlcm5hbWUiOiJodWFqaXlhIiwiZXhwIjoxNjQyMTc4NTM5LCJpc3MiOiJodWFqaXlhIiwiaWF0IjoxNjQyMDkyMTM5fQ.
0UzWrozW9NOa5to-F6cKldtxcnzcZheO8aHYMMOnV3g
```
- `jwt`三部分分别是：`Header（头部）`、`Payload（负载）`、`Signture（签名）`，写成一行就是`Header.Payload.Signature`
##### Header
- `Header`部分是一个`JSON`对象，描述`jwt`的原数据
```js
{
  "alg": "HS256",
  "typ": "JWT"
}
```
- `alg`表示签名的算法，默认是`HMAC SHA256`（写成`HS256`），`typ`属性表示这个令牌（`token`）的类型（`type`），`JWT`令牌统一写为`JWT`。最后，将上面的`JSON`对象使用 `Base64URL`算法转成字符串。
##### Payload
- `Payload`也是一个`JSON`对象，存放实际需要传输的数据，官方提供了7个官方字段：
    - `iss（issuer）`：签发人
    - `exp（expiration time）`：过期时间
    - `sub（subject）`：主题
    - `aud（audience）`：受众
    - `nbf（Not Before）`：生效时间
    - `iat（Issued At）`：签发时间
    - `jti（Jwt Id）`：编号
- 除了使用官方字段，还可以自定义字段，例如自定义`username: username` 
- `jwt`默认不加密，任何人都能读取到，所以不要存放私密信息
- 这个`JSON`对象也要使用`Base64URL`算法转成字符串。
##### Signature
- `Signature`是对前面两部分的签名，防止数据被篡改。
- 首先需要指定一个密钥（`secret`），这个密钥只有服务器知道，不能泄露给用户，然后使用`Header`里面指定的算法（默认是 `HMAC SHA256`），按照下面的公式产生签名：
```js
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```
- 算出签名以后，把`Header、Payload、Signature`三个部分拼成一个字符串，每个部分之间用"点"（`.`）分隔，就可以返回给用户。
#### jwt特点
1. `JWT`默认是不加密，但也是可以加密的。生成原始`Token`以后，可以用密钥再加密一次。
2. `JWT`不加密的情况下，不能将秘密数据写入 `JWT`。
3. `JWT`不仅可以用于认证，也可以用于交换信息。有效使用`JWT`，可以降低服务器查询数据库的次数。
4. `JWT`的最大缺点是，由于服务器不保存`session`状态，因此无法在使用过程中废止某个`token`，或者更改 `token `的权限。也就是说，一旦 `JWT `签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
5. `JWT`本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，`JWT`的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
6. 为了减少盗用，`JWT`不应该使用`HTTP`协议明码传输，要使用`HTTPS`协议传输。

### cookies
`cookie`鉴权流程：
1. 用户第一次访问服务器，服务器设置`cookie`返回给客户端。
2. 客户端从`http`请求头的`set-cookie`字段中拿到服务段返回的`cookie.
3. 下次发送请求时，浏览器会自动将的到的`cookie`设置到请求头的`cookie`字段。

缺点：`cookie`不能跨域，需要手动实现跨域功能。

### Session Cookies
`session cookies`也称为**会话`cookies`**，在`session cookies`中，用户的登录状态会保存在**服务器的内存**中。用户登录时，`session`就会被服务端安全地创建。

`session`是存储在服务端的。客户端请求服务端，服务端就会为这次请求开辟一块内存空间，这块内存空间就是`session`对象。存储结构为`ConcurrentHashMap`。

`session cookies`鉴权流程：

1. 用户端登录发送账号密码，服务端查询数据库，校验用户。
2. 服务端把用户登录状态存到`session`，生成一个`sessionId`。
3. 服务端把`sessionId`设置到`cookie`中返回给用户端。
4. 用户端下次登录时自动带上`cookie`，服务端校验其中的`sessionId`。

缺点：很多时候服务器都是分布式集群，用户每次请求都会走一次负载均衡，指不定走到哪台服务器上。一旦后续请求的服务器和登录时不一样，或者登陆时的那台服务器宕机了，`session`就失效了。

## 跨域及解决方法
### 为什么会跨域

## restful
`restful`是一种互联网软件架构，它结构清晰、符合标准、易于理解、扩展方便。`rest`由一个名为`fielding（菲尔丁）`（`http`协议主要设计者）的人提出。`fielding`将他对互联网软件的架构原则定义为`rest`（`representational state transfer`），翻译过来就是**表现层状态转化**。如果一个架构符合`rest`原则，就称它为`restful`架构。

### restful架构
`restful`特性如下：
1. 每个`URL`代表一种资源，这个资源是网络上的一个实体，可以是文本、图片、歌曲、服务等任何资源。
2. 客户端和服务端之间传递着资源的某种表现层。表现层就是资源呈现出来的形式，例如`txt、XML、JSON`等格式。
3. 客户端通过`http`协议中的几种动词对服务端资源进行操作，实现**表现层状态转化**。

### restful误区
`restful`架构中有一些典型的设计误区：
1. `url`中包含动词——资源表示一种实体，所以`url`中不应该有动词，应该是名词，动词应该放在`http`协议中。
2. `url`中加入版本号——不同的版本可以理解为同一种资源的不同表现形式，应该采用同一个`url`。版本号可以放在`http`请求头中的`Accept`字段中。

### restful设计规范
1. `api`尽量部署在专用域名下：`https://api.example.com`。如果`api`很简单，不会有进一步扩展，可以考虑放在主域名下：`https://example.org/api/`
2. 版本号应该放入`url`：`https://api.example.com/v1/`，另一种做法是将版本号放在`http`头信息中，但不如放在`url`中直观。
3. 路径中不应该有动词，只能由名词，而且名词往往与数据库的表格名相对应。一般来说，数据库中的表都是同一种记录得“集合”，所以`api`中的名词也应该使用复数。
4. 对资源的操作类型由`http`动词表示。
5. 过滤信息：如果记录数量很多，服务器不可能将它们都返回给用户。`api`应该提供参数，过滤返回结果。例如`?limit=10`指定返回记录得数量。
6. 服务器向用户返回的状态码和提示信息应符合规范。
#### http动词
常用的`http`动词有五个，括号中对应`SQL`命令
1. `get（SELECT）`：从服务器中取出资源。
2. `post（CREATE）`：在服务器中新建资源。
3. `put（UPDATE）`：在服务器中替换资源（客户端提供改变后的完整资源）。
4. `patch（UPDATE）`：在服务器中更新资源（客户端）

两个不常用的`http`动词
- `head` ：获取资源的元数据。
- `options`：获取信息，关于资源的哪些属性是客户端可以改变的。
# git

##### 线上代码拉取到本地运行

1. 线上代码拉取到本地`git clone`
2. `sql`拉到本地 假数据
3. 配置`host`文件

这样项目就可以在本地运行。

# 手写题

## instanceof
- 原理：递归不断获取运算符左侧对象的原型，判断与右侧的原型对象是否相等
- 关键 `api`：`Object.getPrototypeOf` 获取对象原型
```js
const myInstanceof = (left, right) => {
  if (typeof left !== 'object' && typeof left !== 'function' || left === null) return false
  let proto = Object.getPrototypeOf(left)   // 获取左侧对象的原型
  while (proto === right.prototype) {  // 找到了就终止循环
    if (proto === null) return false     // 找不到返回 false
    proto = Object.getPrototypeOf(proto)   // 沿着原型链继续获取原型
  }
  return true
}
```
## 实现class私有属性
什么是私有属性：
- 能被 `class` 内部的不同方法访问，但不能在类外部被访问和修改。即实例只能通过类中的方法访问，不能通过属性名直接访问。
- 子类不能继承父类的私有属性
### 约定私有属性命名
- 使用统一的命名规范表示私有属性，遇到该类属性约定俗成不要访问
- 优点：写法简单、调试方便、兼容性好
- 缺点： 
	- 实际上还是可以直接通过属性名直接访问到，即外部可以访问并且可以修改
	- 语言没有配合的机制，比如 `for in` 会将所有可枚举属性枚举出来
	- 有命名冲突的可能
- `es6` 提案中以 `#` 作为私有属性前缀
```js
class Person {
  constructor(password) {
    this.username = username
    this._password = password
  }
  getPassword() {
    return this._password
  }
}
const yzx = new Person('123456')
console.log(yzx._password) // '123456'
console.log(yzx.getPassword()) // '123456'
```
### 利用闭包
- 将属性定义在 `constructor` 作用域内，并在该作用域中定义一个方法返回定义的属性
- 缺点：
	- 私有属性过多会导致 `constructor` 内代码臃肿，维护起来较麻烦
	- 方法定义在 `constructor` 内部，没有挂载到原型链上，子类无法 `super` 调用
```js
class Person {
  constructor(password) {
    const _password = password
    this.getPassword = function () {
      return _password
    }
  }
}
const yzx = new Person('yzx', '123456')
console.log(yzx._password) // undefined
console.log(yzx.getPassword()) // 123456
Person.prototype.getPwd) // undefined
yzx.__proto__.getPassword) // undefined
```
### 闭包进阶版
- 用立即执行函数将类包裹起来，`class` 声明类之后将声明的类 `return` 出去
- 在 `class` 外创建私有变量
- `constructor` 内部对私有变量赋值，形成闭包。`class` 内定义返回私有变量的方法
- 缺陷：闭包创建的私有变量是被实例共享的，所有该类的实例操作的都是同一个属性，只要一个实例创建时修改了这个属性，其他实例也就被修改了
```js
const Person = (function () {
  let _password
  class Person {
    constructor(password) {
      _password = password
    }
    getPassword() {
      return _password
    }
  }
  return Person
})()
const yzx = new Person('123456')
console.log(yzx._password)
console.log(yzx.getPassword())

const lbw = new Person('456')
console.log(lbw.getPassword()) // 456
```
### 闭包进阶 + Symbol
- 闭包进阶版中声明私有变量时等号右侧使用 `Symbol()`
- 缺点：可通过`Object.getOwnPropertySymbols()`获取到`Symbol()`生成的私有变量 
```js
const Person = (function () {
  const _pwd = Symbol('pwd')
  class Person {
    constructor(pwd) {
      this[_pwd] = pwd
    }
    getPwd() {
      return this[_pwd]
    }
  }
  return Person
})()
const yzx = new Person('123')
console.log(yzx.pwd) // undefined
console.log(yzx.getPwd()) // 123

const lbw = new Person('456')
console.log(yzx.getPwd()) // 123
console.log(lbw.getPwd()) // 456

console.log(yzx[Object.getOwnPropertySymbols(yzx)[0]]) // 123

yzx[_pwd] = '111'
console.log(yzx[_pwd]) // ReferenceError: _pwd is not defined
```
### 闭包进阶 + WeakMap
闭包进阶中创建私有变量时等号右侧使用`new WeakMap()`缺点：
1. `WeakMap`是`es6`新的数据结构，有兼容性问题
2. 有一定的性能代价
```js
const Person = (function () {
  const _pwd = new WeakMap()
  class Person {
    constructor(pwd) {
      _pwd.set(this, pwd)
    }
    getPwd() {
      return _pwd.get(this)
    }
  }
  return Person
    
})()
const yzx = new Person('123')
console.log(yzx._pwd) // undefined
console.log(yzx.getPwd()) // 123
```
## 手写call
```js
Function.prototype.myCall = function (context) {
  var context = context || window
  context.fn = this

  let args = []

  for (let i = 1; i < arguments.length; i++) {
    args.push(arguments[i])
  }

  const res = context.fn(...args)
  delete context.fn
  return res
}
```

## 手写apply
```js
Function.prototype.myApply = function (context, arr) {
  var context = context || window
  context.fn = this
  const res = context.fn(...arr)
  delete context.fn
  return res
}
```

## new
`new`操作符会做如下操作

1. 创建一个细新的`javaScript`对象（即 {} ）
2. 为步骤1新创建的对象添加属性`proto` ，将该属性链接至构造函数的原型对象
3. 将`this`指向这个新对象
3. 执行构造函数内部的代码（例如给新对象添加属性）
4. 如果构造函数返回非空对象，则返回该对象，否则返回刚创建的新对象。

```js
function newOperate(ctor, ...args) {
  if (typeof ctor !== 'function') {
    throw new TypeError('Type Error')
  }
  const obj = Object.create(ctor.prototype) // 以ctor的原型为原型创建一个新的对象obj
  const res = ctor.apply(obj, args) // 绑定this，并将 args 传入 obj
  const isObject = typeof res === 'object' && res !== null
  const isFunction = typeof res === 'function'
  return isObject || isFunction ? res : obj
}

function Person(name, age) {
  this.name = name
  this.age = age
}
console.log(newOperate(Person, 'yzx', 22)) 
// Person { name: 'yzx', age: 22 }
```
### 精简版
```js
const myNew = (fn, ...args) => {
  let obj = Object.create(fn.ptototype) // 以fn.prototype为原型创建一个新的对象obj
  let res = fn.call(obj, ...args) // 绑定this并传入参数
  if (res && typeof res === 'object' || typeof res === 'function') {
    return res
  }
  return obj
}
```

### 原始版
```js
const myNew = function (Fn, ...args) {
  const o = {}
  o.__proto__ = Fn.prototype
  const res = Fn.apply(o, args)
  // 判断构造函数是否有返回值
  if (res && typeof res === 'object' || typeof res === 'function') {
    return res
  }
  return o
}
```

## 防抖节流
- 防抖的作用：将多次高频操作优化为只在最后一次执行，一个常见场景是——用户输入校验，用户输入完成后做一次输入校验即可
- 节流的作用：将高频操作稀释成低频操作，常见场景——滚动条事件、`resize（调整窗口大小）`事件。
### 防抖

- 高频率触发事件则在规定时间内只执行一次，期间事件再次出发则重新计时
- 类似于游戏法师的读条技能，读条完毕才触发一次，被打断则重新读条
- 核心考点：闭包、`clearTimeout`、`setTimeout`
```js
function debounce(fn) {
  let timeout          // 创建一个标记用来存放定时器的返回值
  return function () {
    const that = this,
      _args = arguments
    clearTimeout(timeout) // 每当事件触发的时候把前一个 setTimeout clear 掉
    timeout = setTimeout(() => {
      fn.apply(this, _args);
    }, 500);
  }
}
```
- 上面创建的`timeout`在返回的函数体外，形成了闭包，因此每次点击事件都是在同一个`timeout`延时中，如果`timeout`定义在返回的函数内部，那么每次时间触发的`timeout`都是独立的，在延时过后，所有的点击事件都会陆续触发。

### 节流
- 高频率触发事件间隔一段时间执行
- 类似于 fps 游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。
- 核心考点：闭包、`setTimeout`。
```js
function throttle(fn, delay) {
  let timer  
  return function() {
    const that = this,
      _args = arguments
    if (timer) return  // timer有值说明有任务在等待执行，return掉
    timer = setTimeOut(() => {
      fn.apply(this, _args)
      timer = null    // 任务执行后将timer赋值为null，等待下次被赋予延时任务
    }, delay)
  }
}
```
## promise红绿灯
- 使用`promise`实现循环变换红绿灯
- 核心是利用`promise`的`.then()`中的返回的状态会穿透到下一个`.then()`中。红绿灯变化使用`setTimeout`实现。
```js
const red = () => {
  console.log('red')
}
const yellow = () => {
  console.log('yellow')
}
const green = () => {
  console.log('green')
}

const lightPromise = (timer, light) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      light()
      resolve()
    }, timer * 1000)
  })
}

const changeLight = () => {
  Promise.resolve()
    .then(() => {
      return lightPromise(2, green)
    })
    .then(() => {
      return lightPromise(1, yellow)
    })
    .then(() => {
      return lightPromise(2, red)
    })
    .then(() => {
      changeLight()
    })
}
changeLight()
```
### async版本
```js
    const red = () => {
      console.log('red')
    }
    const yellow = () => {
      console.log('yellow')
    }
    const green = () => {
      console.log('green')
    }

    const lightPromise = (timer, light) => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          light()
          resolve()
        }, timer * 1000)
      })
    }

    const changeLight = async () => {
      await lightPromise(2, green)
      await lightPromise(1, yellow)
      await lightPromise(2, red)
      changeLight()
    }
    changeLight()
```

## promisify
- 功能：将异步回调转化成`promise`形式的异步函数
- 核心原理：高阶函数，`promise`，`apply`。
1. `promisify`中返回一个函数，该函数接收参数`...args`，返回一个`new Promsie`
2. 在`promise`中往`args`加入一个普通函数，这个普通函数需要收集原来异步回调函数的回调函数的参数（`...values`），函数中`resolve(values)`
3. 最后在`promise`中为`promisify`的参数也就是原来的异步函数绑定`this`并传入`args`（`original.apply(this, args`）
```js
function promisify(original) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      args.push((...values) => {
        resolve(values)
      })
      original.apply(this, args)
    })
  }
}    

function fnsync(timer, callback) {
  setTimeout(() => {
    callback(1234)
  }, timer)
}

const fn = promisify(fnsync)

fn(1000)
  .then(res => {
    console.log(res, '===========')
  })   // 1秒后打印：1234
```
**版本2**

```js
function promisify(fn) {
  return function(...args) {
  	return new Promise((resolve, reject) => {
  	  fn(...args, (err, data) => {
  	    if (err) return reject(err)
  	    resolve(data)
  	  }
  	})
  }
}
```
## 深浅拷贝
### 浅拷贝
> 创建一个对象，这个对象有着原始对象属性值得一份精准拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，如果其中一个对象改变了这个地址会影响到另一个对象。

![](C:\Users\21133\Pictures\js\qiankaobei.png)

浅拷贝有很多方法可以实现。

1. `Object.assign()`
`Object.assign()`可以把任意多个源对象的可枚举属性拷贝给目标对象，然后返回目标对象。
```js
let obj1 = {a: 1, b: {x: 2, y: 3}}
let obj2 = Object.assign({}, obj1)
console.log(obj2) // {a: 1, b: {x: 2, y: 3}}
```
2. 引用`lodash`库的`_.clone`方法。
```js
const _ = require('lodash')
let obj1 = {a: 1, b: {x: 2, y: 3}}
let obj2 = _.clone(obj1)
```
3. 使用展开运算符
```js
let obj1 = {a: 1, b: {x: 2, y: 3}}
let obj2 = {...obj1}
```
4. `Array.prototype.concat`拷贝数组。
```js
let arr1 = [1, 2, {a: b}]
let arr2 = arr1.concat()
```
5. `Array.prototype.slice()`拷贝数组
```js
let arr1 = [let arr1 = [1, 2, {a: b}]]
let arr2 = arr.slice()
```

### 深拷贝
> 将一个对象从内存中完整地拷贝一份出来，从内存中开辟了一个新的区域存放对象，且修改新对象不会影响原对象。

![](C:\Users\21133\Pictures\js\shenkaobei.png)

#### JSON.parse + JSON.stringfy
第一种实现深拷贝的方法是`JSON.stringfy() + JSON.parse()`，将对象转化成字符串，然后在转化成对象，新对象会开辟新的内存空间，实现深拷贝。

```js
let obj1 = {a: 1, b: {x: 2, y: 3}}
let obj2 = JSON.parse(JSON.stringfy(obj1))
```
这种方式有局限性：`JSON.stringfy()`和`JSON.parse`处理后，正则会变成空对象，函数会变成`null`

#### lodash的_.cloneDeep()方法
`lodash`库中提供了函数`cloneDeep()`方法实现深拷贝。

```js
const _ = require('lodash')
let obj1 = {a: 1, b: {x: 2, y: 3}}
let obj2 = _.cloneDeep(obj1)
```

#### 递归实现
1. 最基础版本
```js
function deepClone(obj) {
  if (typeof obj !== 'object') return obj

  let res = {}
  for (let key in obj) {
    res[key] = deepClone(obj[key])
  }
  return res
}
```
2. 判断数组
```js
function deepClone(obj) {
  if (typeof obj !== 'object') return obj

  let res = Array.isArray(obj) ? [] : {}
  for (let key in obj) {
    res[key] = deepClone(obj[key])
  }
  return res
}
```
3. 考虑其他对象如日期、正则
```js
function deepClone(obj) {
  if (typeof obj !== 'object') return obj
  if (obj instanceof Date) return new Date(obj)
  if (obj instanceof RegExp) return new RegExp(obj)
  let res = Array.isArray(obj) ? [] : {}
  for (let key in obj) {
    res[key] = deepClone(obj[key])
  }
  return res
}
```
4. 考虑循环引用，即对象内部引用自身，并且剔除原型链上的属性，需要使用`obj.hasOwnProperty(key)`判断属性是否只在对象内部。
```js
function deepClone(obj, map = new WeakMap()) {
  if (typeof obj !== 'object') return obj
  if (obj instanceof Date) return new Date(obj)
  if (obj instanceof RegExp) return new RegExp(obj)

  if (map.has(obj)) return map.get(obj)

  let res = new obj.constructor()
  map.set(obj, res)
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      res[key] = deepClone(obj[key], map)
    }
  }
  return res
}
```

## 时间格式转换
**协调世界时**格式中带有字母`T`和`Z`标识，除了世界协调时间格式，还有很多其他的时间格式，如果要得到相应的北京时间，需要转化。

**协调世界时**时间格式如下：

```js
2022-04-05T11:26:10.611Z
```

世界协调时与北京时间有8小时的时差，将原有时间加上八小时再转化为世界协调时，再正则去调整为北京时间格式。

`Date.prototype.toISOString`方法可以将任意时间格式时间转化为**协调时间时**，然后正则去多余数字和标识字母。

```js
function rTime(date) {
  const ISODate = new Date(date8 * 3600 * 1000).toISOString()
  return ISODate.replace(/T/g, ' ').replace(/\.[\d]{3}Z/, '')
}
```


# 问答题
## 左侧固定右侧自适应布局

一个 `div` 中包含两个子 `div`，如何使得一个子 `div` 固定在左侧，另一个在右侧自适应

### flex布局实现
- 父元素设置为 `display: flex`
- 子元素 `left` 设置 固定 `witch` 或者 `flex-basis`
- 子元素 `right` 设置 `flex: 1`

缺点：`flex`布局有兼容性问题，不是所有浏览器都支持。
```html
<div class="container">
  <div class="left"></div>
  <div class="right"></div>
</div>
```
```css
  * {
    margin: 0;
    padding: 0;
  }

  .container,
  .left,
  .right {
    height: 100px;
  }

  .container {
    display: flex;
    /* flex-direction: column; */
    width: 200px;
  }

  .left {
    background-color: green;
    width: 100px;
    /* flex-basis: 100px; */
  }

  .right {
    background-color: red;
    flex: 1
  }
```

### float + bfc
使用`float:left`将一个元素浮动在左侧，另一个元素使用`overflow:hidden`创建`bfc`达到与左侧浮动元素不重叠的目的，最后为了解决父元素塌陷，应该清除浮动。

缺点：代码略显复杂，需要用到伪元素清除浮动。
```html
  <div class="container">
    <div class="left"></div>
    <div class="right"></div>
  </div>
```
```css
.container{
      margin: 0;
      padding: 0;
      width: 500px;
      height: 200px;
      border: 1px solid #000;
      overflow: hidden;
    }
.left{
  float: left;
  width: 200px;
  height: 100%;
  background-color: aqua;
}
.right {
  overflow: hidden;
  height: 100%;
  background-color: red;
}
.container::after{
  content: "";
  height: 0;
  line-height: 0;
  display: block;
  visibility: hidden; // 使伪元素不可见并且不影响父元素的事件触发
}
```

### float + margin
左侧元素浮动到左边，右侧元素左侧外边距等于左侧元素宽度。

缺点：此方法必须知道左侧元素宽度，后期还需要考虑各个元素`border`的影响，需要设置`box-sizing`。此方法设置的右侧元素只能相对父元素自适应，如果左侧元素宽度发生变化，右侧元素可能会与左侧元素重叠或者相离。

```html
  <div class="container">
    <div class="left"></div>
    <div class="right"></div>
  </div>
```
```css
.container {
  margin: 0;
  padding: 0;
  width: 500px;
  height: 200px;
  border: 1px solid #000;
  overflow: hidden;
}

.left {
  float: left;
  width: 200px;
  height: 100%;
  background-color: aqua;
}

.right {
  margin-left: 200px;
  height: 100%;
  background-color: red;
}

.container::after {
  content: "";
  height: 0;
  line-height: 0;
  display: block;
  visibility: hidden;
}
```

### position + margin
与`float + margin`类似，通过绝对定位将左侧元素固定在左侧，右侧`margin-left`与左侧元素的宽度相等。

缺点：无法清除浮动，也就是父元素的如果出现高度塌陷无法解决，左侧元素的宽高不受父元素的`overflow`影响，左侧元素已经脱离文档流。

```html
  <div class="container">
    <div class="left"></div>
    <div class="right"></div>
  </div>
```

```css
    .container {
      margin: 0;
      padding: 0;
      width: 500px;
      height: 200px;
      border: 1px solid #000;
      overflow: hidden;
      position: relative;
    }

    .left {
      position: absolute;
      left: 0;
      top: 0;
      width: 200px;
      height: 100%;
      background-color: aqua;
    }

    .right {
      margin-left: 200px;
      height: 200px;
      background-color: red;
    }
```

### 双float + calc()
将左右元素都浮动起来脱离文档流，这样他们就不会占据一行，然后使用`calc()`函数动态计算右侧元素的宽度，注意`calc()`函数书写规范，使用`+`、`-`计算符时左右需要有一个空格。

```html
  <div class="container">
    <div class="left"></div>
    <div class="right"></div>
  </div>
```

```css
 .container {
      margin: 0;
      padding: 0;
      width: 500px;
      height: 200px;
      border: 1px solid #000;
      overflow: hidden; 
}

.left {
  float: left;
  width: 200px;
  height: 100%;
  background-color: aqua;
}

.right {
  float: left;
  height: 200px;
  width: calc(100% - 200px);
  background-color: red;
}
```

### 双inline-block + calc()
利用块级行内元素的特性：块级行内元素不会占据一行且能计算宽度。将两个元素都设置为块级行内元素，右侧元素使用`calc()`函数计算宽度。

**注意**：这里需要给父元素设置`font-size: 0;`来消除两个块级行内元素之间的间隙，不然右侧元素会被挤到下方。如果盒子后续还需要设置`border`的话，左右两个盒子需要设置`boeder-box: box-sizing`来改变盒模型计算方式。

```html
  <div class="container">
    <div class="left"></div>
    <div class="right"></div>
  </div>
```

```css
.container {
  margin: 0;
  padding: 0;
  width: 500px;
  height: 200px;
  border: 1px solid #000;
  overflow: hidden;
  font-size: 0;
}

.left {
  display: inline-block;
  width: 200px;
  height: 100%;
  background-color: aqua;
}

.right {
  display: inline-block;
  height: 200px;
  width: calc(100% - 200px);
  background-color: red;
}
```


## 输入url到页面渲染（首屏渲染过程）

大致流程：
1. `DNS`解析
2. 发送`TCP`连接
3. 发送`http`请求
4. 服务器处理请求并返回`http`报文
5. 浏览器解析渲染页面
6. 连接结束

### DNS查询
域名需要转化成`ip`地址服务器才能够识别。本地设备的域名操作保存在一个文件（`C:/Windows/System32/drivers/etc/hosts`），这个文件是可配置的。


`dns`域名查询是将域名转化成`ip`地址。这个查找过程是递归的。

## 网站资源优化
问：如何对网站的文件和资源进行优化？

1. 减少 `http` 请求
2. 正确理解重绘和重排，减少 `DOM` 操作
3. 使用 `JSON` 格式来进行数据交换
4. 高效使用 `html` 和 `css`
5. 压缩 `html`、`css` 和 `js` 文件
6. 使用 `CDN` 加速(内容分发网络)
7. `css` 和 `js` 放到外部文件中引用，`css` 放在头部，`js` 放在尾部
8. 精简 `css` 和 `js` 文件
9. 压缩图片
10. 控制 `cookie` 大小和污染
11. 避免重定向


## PWA
全称`Progressive Web Apps`，渐进式`web`应用。指的是使用指定技术和标准模式来开发的`web`应用，这同时赋予它们`web`应用和原生应用的特性。
- `web`应用更容易发现，相比于安装应用，访问一个网站更容易更迅速，还可以通过链接分享`web`应用。
- 原生应用与操作系统可以更加完美地整合，也因此为用户提供了无缝的用户体验。安装应用使得它在离线状态下也可以运行；。相比于用浏览器访问，用户也更喜欢点击主页上的图标来访问他们喜爱的应用。

`PWA`能够同时拥有以上两种应用的优势。一个`PWA`应用应该具有以下特点：
1. 可发现——可以通过搜索引擎发现
2. 可安装——可以出现在设备的主屏
3. 可链接——可以简单滴通过`URL`分享
4. 独立于网络——可以在离线状态或者网速很差的情况下运行
5. 渐进式——在老版本浏览器让然可以使用，在新版本浏览器可以使用全部功能。
6. 可重入——无论何时有新的内容，都可以发送内容
7. 响应式——在任何具有屏幕和浏览器的设备上可以正常使用
8. 安全——在用户、应用和服务器之间的连接是安全的，第三方无法访问敏感数据。

## 调用设备硬件
如何调用设备的硬件？
- ` MediaDevices.getUserMedia()`：调用设备的音频或者视频功能。
- ` MediaStream`：一个构造函数，它的实例是媒体流内容的集合载体。可能包含多个媒体数据轨，每个数据轨则由一个`MediaStreamTeack`对象表示。

## 星级评分组件

问：实现一个星级评分组件，简述主要思路和伪代码

## 原生js对比框架
用原生`js`和`react`框架写一样的项目，哪个项目运行的更快？
- 原生`js`的运行速度快于框架。因为框架运行需要加载各个模块，运行第三方插件，工程化的项目还有打包文件、生成本地文件、生成虚拟`DOM`等等操作需要耗时

# 编程题

### Fizz || Buzz
写一个程序，输出从1到 n 数字的字符串表示。
1. 如果 n 是3的倍数，输出“Fizz”；
2. 如果 n 是5的倍数，输出“Buzz”；
3. 如果 n 同时是3和5的倍数，输出“FizzBuzz”。

```js
let i = readline();
for (let i = 1; i <= n; i++) {
    if (i % 3 === 0) {
      if (i % 5 !== 0) {
        console.log('Fizz');
      } else {
        console.log('FizzBuzz');
      }
    } else if (i % 5 === 0) {
      console.log('Buzz');
    } else {
      console.log(i);
    }
  }
```

### 两数相乘，保证精度

- 思路：获取两个数的小数位数n和m，将两个数字都乘于10的n次方，再将两数相乘，最后除于10的n+m次方，全程没有小数与小数的乘法计算，不会丢失精度

- 代码
```js
function multiply(a, b) {
  let _a = a.toString(),
    _b = b.toString(),
    m = (_a.indexOf('.') === -1) ? 0 : (_a.substring(_a.indexOf('.') + 1).length),
    n = (_b.indexOf('.') === -1) ? 0 : (_b.substring(_b.indexOf('.') + 1).length)

  return ((a * Math.pow(10, m) * (b * Math.pow(10, n)) / Math.pow(10, m + n)))
}
console.log(multiply(3, 0.0001));  // 0.0003
```
### 原生js与框架运行项目孰快孰慢

# 牛客笔试

## 选择题
###### midir 选项
- -m：设置权限。
- -p：如果路径中不存在相关目录，自动创建文件夹。
- -v：每创建一个目录就打印一次消息。
- -Z：将SELinux 安全上下文 设置为所创建文件夹的默认类型。
###### git branch

- git branch -r  查看远程分支
- git branch -a  查看当前所有分支，包括本地和服务器
- git branch –d  删除分支
- git branch  查看本地分支
###### git提交完代码发现提交信息有误，如何改正
- git commit --amend  对上次提交的内容进行修改，也可以修改提交说明。
###### decodeURIComponent()
`decodeURIComponent()`方法用于解码由`encodeURIComponent`方法或者其它类似方法编码的部分统一资源标识符（`URI`）。

```js
//解码一个西里尔字母的URL
decodeURIComponent("JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B");
// "JavaScript_шеллы"

//捕捉异常
try {
  var a = decodeURIComponent('%E0%A4%A');
} catch(e) {
  console.error(e);
}

// URIError: malformed URI sequence
```
###### append
- `append(content)`方法向每个匹配的元素内部追加内容。
```js
<p>I come from </p><p>I love  </p> 
$("p").append("china");

//结果
<p>I come from china</p><p>I love china </p>
```
- appendTo(expr)方法把所有匹配的元素追加到指定的元素元素集合中。
```js
<b>I love china </b><p></p>
$("b").appendTo("p");

//结果
<p><b>I love china </b></p>
```
###### 鼠标、键盘、点击事件
- `click`是鼠标点击事件。
- `contextmenu`是当浏览者按下鼠标右键出现菜单时或者通过键盘的按键触发页面菜单时触发的事件。
- `onContentMenu="return false"`就可禁止使用鼠标右键了。
- `mouseout`事件会在鼠标指针移出指定的对象时发生。
- `keydown`事件会在用户按下一个键盘按键时发生，由键盘触发。
###### 跨域解决
- `jsonp`：`jsonp`的原理是利用`<script>`等拥有`src`属性标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有`<img>`.
- `document.domain`：这种方式用在主域名相同子域名不同的跨域访问中
- `window.name`：`window`的`name`属性有个特征：在一个窗口(`window`)的生命周期内,窗口载入的所有的页面都是共享一个`window.name`的，每个页面对`window.name`都有读写的权限，`window.name`是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
- `window.postMessage`：`window.postMessages`是`html5`中实现跨域访问的一种新方式，可以使用它来向其它的`window`对象发送消息，无论这个`window`对象是属于同源或不同源。
- `CORS`：`CORS`背后的基本思想，就是使用自定义的`HTTP`头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。
- `Web Sockets`：`web sockets`原理——在JS创建了`web socket`之后，会有一个`HTTP`请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用`HTTP`升级从`HTTP`协议交换为`web sockt`协议。
######  浏览列表
与浏览列表有关的对象:History Screen Location Navigator
- History: History 接口允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录，History 接口不继承于任何属性
- Screen: 屏幕对象，Screen 接口表示一个屏幕窗口，往往指的是当前正在被渲染的window对象，可以使用 window.screen 获取它。
- Location: 位置对象，Location 接口表示其链接到的对象的位置（URL），所做的修改反映在与之相关的对象上。 Document 和 Window 接口都有这样一个链接的Location。
- Navigator: Navigator 接口表示用户代理的状态和标识。 它允许脚本查询它和注册自己进行一些活动。可以使用只读的 window.navigator 属性检索navigator对象。
###### position
- absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位，元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定；
- fixed：生成绝对定位的元素，相对于浏览器窗口进行定位，元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
- relative：生成相对定位的元素，相对于其正常位置进行定位
- static，默认值，没有定位，元素出现在正常的流中(忽略 top, bottom, left, right 或者 z-index 声明）
- inherit：规定应该从父元素继承 position 属性的值，其他属性也可以使用inherit继承父元素相应的属性值
###### overflow
- scroll：必会出现滚动条
- auto：子元素内容大于父元素时出现滚动条
- visible：溢出的内容出现在父元素之外
- hidden：溢出则隐藏
###### RegExp三个方法
- test()：检测一个字符串是否匹配某个正则表达式，如果匹配成功，返回 true ，否则返回 false
- exec()：检索字符串中与正则表达式匹配的值。exec() 方法返回一个数组，其中存放匹配的结果。如果未找到匹配的值，则返回 null
- compile() ：在脚本执行过程中编译正则表达式，也可以改变已有表达式。
**match是支持正则表达式的String对象的方法**
###### DOM事件
- onload() 元素被载入(文档，框架或图像)时触发
- onclick() 鼠标点击一个元素时触发
- onchange()  事件会在域的内容改变时发生
- onblur()  在对象失去焦点时发生
- onreset() 当收到一个reset事件(用户点击表单中的reset按钮)时触发
###### Audio/Video(音频/视频)方法
- addTextTrack() 向音频/视频添加新的文本轨道
- canPlayType()	检测浏览器是否能播放指定的音频/视频类型
- load() 重新加载音频/视频元素
- play() 开始播放音频/视频
- pause() 暂停当前播放的音频/视频

###### 哪些 CSS 属性可能会触发 GPU 硬件加速

- transform
- opacity
- filter
- will-change

###### http2 特性

- 解决了浏览器线头阻塞的问题
- 使用了头部压缩
- 使用二进制分帧封装HTTP 消息

###### 防止xss攻击的手段

- 过滤用户请求中的非法字符
- 对请求中的特殊字符进行转译
- 配置CSP（Content Security Policy）

###### 排序算法复杂度

![808ECC7E37B01281C29E8D9DEC454781](C:\Users\21133\Documents\B-JS\js知识点\js知识点图解\808ECC7E37B01281C29E8D9DEC454781.png)

###### transform 特点

- 只对受控于盒模型的元素生效
- 可以通过matrix函数整合多种变形效果
- 变形默认原点是中心
- 变性后占位不会发生变化，会创建一个新的图层来显示

###### webpack正确描述

- Webpack 是一个模块打包工具
- Webpack 可以实现热更新，开发更加高效

###### 哪些方法会中断js执行

- alert
- sync ajax请求

###### 哪些是应用层协议

- HTTP 超文本传输协议
- SSH  安全外壳协议，为建立在应用层基础上的安全协议
- FTP  文件传输协议，是网络中实现文件传输的一种标准协议。
	-其他层协议
	-  SSL/TLS  工作在应用层和传输层之间的协议
	- IP  网络层协议，网络之间互联的协议
	- TCP  传输层协议，是一种面向连接的、可靠地、基于字节流的传输层通信协议
###### 浏览器缓存优先级

- 浏览器会先在浏览器缓存中查询是否有要请求的文件满足需求，再决定是否发送请求
- 浏览器缓存是性能优化中简单高效的一种方式，按照缓存位置划分为以下几种类型：service Worker --> Memory Cache --> Disk Cache --> Push Cache 浏览器请求时，会按照如上的优先级顺序，进行查找缓存，都没有命中时，才会去请求网络

###### GDK&&UTF-8编码

- GBK：中文、英文、数字均使用双字节来表示
- UTF-8：汉字占3个字节、数字占1个字节、英文字母占1个字节
- GDK 和 UTF-8 都包含中文简体和繁体字符

###### js模块化规范

- AMD
- CMD
- CJS（CommonJS）
- UMD
- ESM

###### 服务端渲染 && 客户端渲染

- 服务端渲染的优点
	- 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。
	- 更快的内容到达时间，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。
-  SPA是客户端渲染的

###### Linux操作系统普通用户变为管理员的操作

- su
- 修改/etc/passwd 文件

###### https 协议描述正确的是（加密）

- HTTPS 协议同时用到了对称加密（共享密钥加密）和非对称加密（公开密钥加密）
- HTTPS 实现内容完整性的手段主要是摘要算法
- 数字签名是私钥对内容摘要的加密
- HTTPS加密请求(一次握手)过程：客户端发起握手请求，**以明文传输请求信息**，包含版本信息，加密-套件候选列表，压缩算法候选列表，随机数，扩展字段等信息。

###### js声明数字的代码

-  const a = 0xa1  十六进制
- const a = 076  八进制
- const a = 7e2  指数
-  const a = 0b21  二进制，只有0和1，不应该出现2，因此错误

###### cookie和session

该session是服务端的session而不是sessionStorage

- cookie数据存放在客户的浏览器上，session数据放在服务器
- cookie和session都可以设置过期时间（有效期）
- session不可以在多个服务器之间共享

###### CPU内部结构

- 寄存器 
- 控制器 
- 运算器 
- 时钟

###### css哪些操作可能触发回流

- outline-width
- border-width

###### 判断空数组的方法

- 

###### 前端构建工具

最常见的有六种：npm script , grunt, gulp, fis3, webpack, rollup(专注于es6)

###### Linux操作系统的Cron服务

用于管理系统日常任务的调度。cron（crond）是linux下用来**周期性的执行某种任务或等待处理某些事件**的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，**crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。**

###### 使用 git 不小心 commit 了，如何恢复到上一状态？

- git reset HEAD --soft  回撤提交到暂存区
- git reset HEAD --hard   回撤提交 放弃变更 (慎用)
- git checkout 分支名   检出分支
- git revert HEAD  撤销最近一次提交 ,git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的

###### Linux命令权限命令

- chmod：更改文件9个属性
- chown：更改文件属主，也可以同时更改文件属组
- chgrp：更改文件属组。
- umask设置预设的权限掩码
- file：辨识该文件的类型
- attrib：对文件夹添加或者删除属性

###### IPv4 地址由几位二进制数组成

- IPv4 32位
- IPv6 128位
###### flex布局

- flex可以实现单行和单列布局
- flex可以多行布局，但是多行布局时候，会遇到space-around属性值导致多行元素对不齐的情况
- flex-grow属性定义项目的放大比例，默认为0，存在剩余空间也不放大，只按照规定的比例放大。

###### 锚（anchor）伪类

- 未访问状态（a:link）
- 鼠标悬停状态（a:hover）
- 活动状态（a:active）
- 已访问状态（a:visited）
###### 事件监听

- e.target获取的是触发该事件的元素，也就是点击事件绑定了ul,但是点了ul里面的li,那么target指的是li
- 事件捕获和事件冒泡的顺序是先捕获后冒泡
- 通过使用事件代理可以提高性能，也有较好的可扩展性
-  addEventListener有三个参数，第三个参数默认是false，默认事件句柄在冒泡阶段执行，第三个参数为true就是让事件句柄在捕获阶段执行

###### 常见浏览器内核

- Trident：国内很多的双核浏览器的其中一核便是 Trident，IE、傲游、猎豹安全浏览器、360极速浏览器、百度浏览器等。Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。
- Gecko：Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高。
- Webkit Safari：苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。
- Bink：内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。
- Presto：挪威产浏览器 opera 的 "前任" 内核。

###### css选择器权重

| **内联**               | **1000** |
| :--------------------- | :------- |
| **id**                 | **100**  |
| **class \|\| 伪类**    | **10**   |
| **标签选择器&&伪元素** | **1**    |

###### MAX_VALUE&&MIN_VALUE

- MAX_VALUE：接近1.79E+308，大于 MAX_VALUE 的值代表 Infinity
- MIN_VALUE：约为5 x 10-324，接近零，不为负

 
